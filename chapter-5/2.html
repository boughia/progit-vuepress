<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>向一个项目贡献 | Pro Git</title>
    <meta name="description" content="Pro Git 第二版中文版">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.130772cc.css" as="style"><link rel="preload" href="/assets/js/app.e343c26e.js" as="script"><link rel="preload" href="/assets/js/2.c0327591.js" as="script"><link rel="preload" href="/assets/js/5.b1d6f09c.js" as="script"><link rel="prefetch" href="/assets/js/10.0f9cab2e.js"><link rel="prefetch" href="/assets/js/100.83085317.js"><link rel="prefetch" href="/assets/js/101.56c6cce3.js"><link rel="prefetch" href="/assets/js/102.415183d7.js"><link rel="prefetch" href="/assets/js/103.65e1f37c.js"><link rel="prefetch" href="/assets/js/104.4844f2f3.js"><link rel="prefetch" href="/assets/js/105.66c87d19.js"><link rel="prefetch" href="/assets/js/106.05b2e48e.js"><link rel="prefetch" href="/assets/js/107.929c5d0f.js"><link rel="prefetch" href="/assets/js/108.7b376e69.js"><link rel="prefetch" href="/assets/js/109.1a730133.js"><link rel="prefetch" href="/assets/js/11.a6d7b909.js"><link rel="prefetch" href="/assets/js/110.191355ad.js"><link rel="prefetch" href="/assets/js/111.a049971f.js"><link rel="prefetch" href="/assets/js/112.482ffc61.js"><link rel="prefetch" href="/assets/js/113.d94b639c.js"><link rel="prefetch" href="/assets/js/114.8b9356fb.js"><link rel="prefetch" href="/assets/js/115.ebf1e18a.js"><link rel="prefetch" href="/assets/js/116.18b899b1.js"><link rel="prefetch" href="/assets/js/117.42a1b8c4.js"><link rel="prefetch" href="/assets/js/118.3a9d2ee3.js"><link rel="prefetch" href="/assets/js/119.4020833f.js"><link rel="prefetch" href="/assets/js/12.5d2796d3.js"><link rel="prefetch" href="/assets/js/120.9fae7990.js"><link rel="prefetch" href="/assets/js/121.cb3ef973.js"><link rel="prefetch" href="/assets/js/13.f69c9e48.js"><link rel="prefetch" href="/assets/js/14.6debe4be.js"><link rel="prefetch" href="/assets/js/15.a7c94022.js"><link rel="prefetch" href="/assets/js/16.6609021c.js"><link rel="prefetch" href="/assets/js/17.34ba32b5.js"><link rel="prefetch" href="/assets/js/18.4dd74348.js"><link rel="prefetch" href="/assets/js/19.2f410429.js"><link rel="prefetch" href="/assets/js/20.16ec0bd3.js"><link rel="prefetch" href="/assets/js/21.ad1ca29b.js"><link rel="prefetch" href="/assets/js/22.293aa5c6.js"><link rel="prefetch" href="/assets/js/23.025d3c7a.js"><link rel="prefetch" href="/assets/js/24.770fb3e1.js"><link rel="prefetch" href="/assets/js/25.6ce5a0ac.js"><link rel="prefetch" href="/assets/js/26.6404265b.js"><link rel="prefetch" href="/assets/js/27.62decef4.js"><link rel="prefetch" href="/assets/js/28.d1136794.js"><link rel="prefetch" href="/assets/js/29.95a71153.js"><link rel="prefetch" href="/assets/js/3.c6496835.js"><link rel="prefetch" href="/assets/js/30.eae133de.js"><link rel="prefetch" href="/assets/js/31.a6e572c3.js"><link rel="prefetch" href="/assets/js/32.4fc54ce1.js"><link rel="prefetch" href="/assets/js/33.d1c0ecba.js"><link rel="prefetch" href="/assets/js/34.29586ee8.js"><link rel="prefetch" href="/assets/js/35.8e480916.js"><link rel="prefetch" href="/assets/js/36.5b537183.js"><link rel="prefetch" href="/assets/js/37.40c06fd9.js"><link rel="prefetch" href="/assets/js/38.555815d4.js"><link rel="prefetch" href="/assets/js/39.6d5293e5.js"><link rel="prefetch" href="/assets/js/4.e8424aa9.js"><link rel="prefetch" href="/assets/js/40.78797741.js"><link rel="prefetch" href="/assets/js/41.ac76af08.js"><link rel="prefetch" href="/assets/js/42.e7d51b5d.js"><link rel="prefetch" href="/assets/js/43.b20d0fd6.js"><link rel="prefetch" href="/assets/js/44.e29a7c46.js"><link rel="prefetch" href="/assets/js/45.cdea70ee.js"><link rel="prefetch" href="/assets/js/46.9c95c270.js"><link rel="prefetch" href="/assets/js/47.ba588e60.js"><link rel="prefetch" href="/assets/js/48.a8b188ed.js"><link rel="prefetch" href="/assets/js/49.5c609647.js"><link rel="prefetch" href="/assets/js/50.662cc18e.js"><link rel="prefetch" href="/assets/js/51.5ff994dd.js"><link rel="prefetch" href="/assets/js/52.b1b6dd6c.js"><link rel="prefetch" href="/assets/js/53.bd783506.js"><link rel="prefetch" href="/assets/js/54.a05ff5b6.js"><link rel="prefetch" href="/assets/js/55.c30a6cad.js"><link rel="prefetch" href="/assets/js/56.44021f37.js"><link rel="prefetch" href="/assets/js/57.90e56f36.js"><link rel="prefetch" href="/assets/js/58.9ec15505.js"><link rel="prefetch" href="/assets/js/59.8f4ffc72.js"><link rel="prefetch" href="/assets/js/6.49fca771.js"><link rel="prefetch" href="/assets/js/60.8064b38b.js"><link rel="prefetch" href="/assets/js/61.d570ac20.js"><link rel="prefetch" href="/assets/js/62.c66ac933.js"><link rel="prefetch" href="/assets/js/63.d01f285e.js"><link rel="prefetch" href="/assets/js/64.a04e3c07.js"><link rel="prefetch" href="/assets/js/65.af0f13b3.js"><link rel="prefetch" href="/assets/js/66.f81074cc.js"><link rel="prefetch" href="/assets/js/67.47db8798.js"><link rel="prefetch" href="/assets/js/68.50332586.js"><link rel="prefetch" href="/assets/js/69.059056ac.js"><link rel="prefetch" href="/assets/js/7.225eae41.js"><link rel="prefetch" href="/assets/js/70.c46fd0e9.js"><link rel="prefetch" href="/assets/js/71.d45f53f9.js"><link rel="prefetch" href="/assets/js/72.eef7975a.js"><link rel="prefetch" href="/assets/js/73.d947c914.js"><link rel="prefetch" href="/assets/js/74.cc528edb.js"><link rel="prefetch" href="/assets/js/75.7e89a25f.js"><link rel="prefetch" href="/assets/js/76.68b7cb39.js"><link rel="prefetch" href="/assets/js/77.f51671b0.js"><link rel="prefetch" href="/assets/js/78.d940a766.js"><link rel="prefetch" href="/assets/js/79.657d22ce.js"><link rel="prefetch" href="/assets/js/8.1c488769.js"><link rel="prefetch" href="/assets/js/80.b7eef56c.js"><link rel="prefetch" href="/assets/js/81.5a9ab73c.js"><link rel="prefetch" href="/assets/js/82.82f8101f.js"><link rel="prefetch" href="/assets/js/83.16c731ea.js"><link rel="prefetch" href="/assets/js/84.ebb4499e.js"><link rel="prefetch" href="/assets/js/85.323932c6.js"><link rel="prefetch" href="/assets/js/86.5fe42af0.js"><link rel="prefetch" href="/assets/js/87.1e607b95.js"><link rel="prefetch" href="/assets/js/88.1cb1bb53.js"><link rel="prefetch" href="/assets/js/89.30b0fda7.js"><link rel="prefetch" href="/assets/js/9.c748d72e.js"><link rel="prefetch" href="/assets/js/90.050be28f.js"><link rel="prefetch" href="/assets/js/91.57dee3b4.js"><link rel="prefetch" href="/assets/js/92.5ec93ebb.js"><link rel="prefetch" href="/assets/js/93.5a3e28cc.js"><link rel="prefetch" href="/assets/js/94.ab209645.js"><link rel="prefetch" href="/assets/js/95.2a4ea0e2.js"><link rel="prefetch" href="/assets/js/96.41db9364.js"><link rel="prefetch" href="/assets/js/97.b936622c.js"><link rel="prefetch" href="/assets/js/98.32537222.js"><link rel="prefetch" href="/assets/js/99.64a3e64d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.130772cc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Pro Git</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">引言</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-1/" class="sidebar-heading clickable"><span>1. 起步</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-2/" class="sidebar-heading clickable"><span>2. Git 基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-3/" class="sidebar-heading clickable"><span>3. Git 分支</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-4/" class="sidebar-heading clickable"><span>4. 服务器上的 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-5/" class="sidebar-heading clickable router-link-active open"><span>5. 分布式 Git</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/chapter-5/1.html" class="sidebar-link">分布式工作流程</a></li><li><a href="/chapter-5/2.html" class="active sidebar-link">向一个项目贡献</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/chapter-5/2.html#提交准则" class="sidebar-link">提交准则</a></li><li class="sidebar-sub-header"><a href="/chapter-5/2.html#私有小型团队" class="sidebar-link">私有小型团队</a></li><li class="sidebar-sub-header"><a href="/chapter-5/2.html#私有管理团队" class="sidebar-link">私有管理团队</a></li><li class="sidebar-sub-header"><a href="/chapter-5/2.html#派生的公开项目" class="sidebar-link">派生的公开项目</a></li><li class="sidebar-sub-header"><a href="/chapter-5/2.html#通过邮件的公开项目" class="sidebar-link">通过邮件的公开项目</a></li><li class="sidebar-sub-header"><a href="/chapter-5/2.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/chapter-5/3.html" class="sidebar-link">维护项目</a></li><li><a href="/chapter-5/4.html" class="sidebar-link">总结</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-6/" class="sidebar-heading clickable"><span>6. GitHub</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-7/" class="sidebar-heading clickable"><span>7. Git 工具</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-8/" class="sidebar-heading clickable"><span>8. 自定义 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-9/" class="sidebar-heading clickable"><span>9. Git 与其他系统</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-10/" class="sidebar-heading clickable"><span>10. Git 内部原理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/appendix-A/" class="sidebar-heading clickable"><span>附录 A. 在其它环境中使用 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/appendix-B/" class="sidebar-heading clickable"><span>附录 B. 在你的应用中嵌入 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/appendix-C/" class="sidebar-heading clickable"><span>附录 C. Git 命令</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="向一个项目贡献"><a href="#向一个项目贡献" class="header-anchor">#</a> 向一个项目贡献</h1> <p>
描述如何向一个项目贡献的主要困难在于完成贡献有很多不同的方式。
因为 Git 非常灵活，人们可以通过不同的方式来一起工作，所以描述应该如何贡献并不是非常准确——每一个项目都有一点儿不同。
影响因素包括活跃贡献者的数量、选择的工作流程、提交权限与可能包含的外部贡献方法。</p> <p>第一个影响因素是活跃贡献者的数量——积极地向这个项目贡献代码的用户数量以及他们的贡献频率。
在许多情况下，你可能会有两三个开发者一天提交几次，对于不活跃的项目可能更少。
对于大一些的公司或项目，开发者的数量可能会是上千，每天都有成百上千次提交。
这很重要，因为随着开发者越来越多，在确保你的代码能干净地应用或轻松地合并时会遇到更多问题。
提交的改动可能表现为过时的，也可能在你正在做改动或者等待改动被批准应用时被合并入的工作严重损坏。
如何保证代码始终是最新的，并且提交始终是有效的？</p> <p>下一个影响因素是项目使用的工作流程。
它是中心化的吗，即每一个开发者都对主线代码有相同的写入权限？
项目是否有一个检查所有补丁的维护者或整合者？
是否所有的补丁是同行评审后批准的？
你是否参与了那个过程？
是否存在副官系统，你必须先将你的工作提交到上面？</p> <p>下一个影响因素是提交权限。
是否有项目的写权限会使向项目贡献所需的流程有极大的不同。
如果没有写权限，项目会选择何种方式接受贡献的工作？
是否甚至有一个如何贡献的规范？
你一次贡献多少工作？
你多久贡献一次？</p> <p>所有这些问题都会影响实际如何向一个项目贡献，以及对你来说哪些工作流程更适合或者可用。
我们将会由浅入深，通过一系列用例来讲述其中的每一个方面；从这些例子应该能够建立实际中你需要的特定工作流程。</p> <h2 id="提交准则"><a href="#提交准则" class="header-anchor">#</a> 提交准则</h2> <p>在我们开始查看特定的用例前，这里有一个关于提交信息的快速说明。
有一个好的创建提交的准则并且坚持使用会让与 Git 工作和与其他人协作更容易。
Git 项目提供了一个文档，其中列举了关于创建提交到提交补丁的若干好的提示——可以在 Git 源代码中的 <code class="literal">Documentation/SubmittingPatches</code> 文件中阅读它。</p> <p>
首先，你的提交不应该包含任何空白错误。
Git 提供了一个简单的方式来检查这点——在提交前，运行 <code class="literal">git diff --check</code>，它将会找到可能的空白错误并将它们为你列出来。</p> <figure class="image"><div class="content"><img src="/assets/img/git-diff-check.c69eff7e.png" alt="`git diff --check` 的输出。"></div> <figcaption>Figure 4. <code class="literal">git diff --check</code> 的输出</figcaption></figure> <p>如果在提交前运行那个命令，可以知道提交中是否包含可能会使其他开发者恼怒的空白问题。</p> <p>接下来，尝试让每一个提交成为一个逻辑上的独立变更集。
如果可以，尝试让改动可以理解——不要在整个周末编码解决五个问题，然后在周一时将它们提交为一个巨大的提交。
即使在周末期间你无法提交，在周一时使用暂存区域将你的工作最少拆分为每个问题一个提交，并且为每一个提交附带一个有用的信息。
如果其中一些改动修改了同一个文件，尝试使用 <code class="literal">git add --patch</code> 来部分暂存文件（在 <a id="xref--ch07-git-tools--_interactive_staging" href="/chapter-7/2.html#交互式暂存" class="xref">交互式暂存</a> 中有详细介绍）。
不管你做一个或五个提交，只要所有的改动是在同一时刻添加的，项目分支末端的快照就是独立的，使同事开发者必须审查你的改动时尽量让事情容易些。</p> <p>当你之后需要时这个方法也会使拉出或还原一个变更集更容易些。
<a id="xref--ch07-git-tools--_rewriting_history" href="/chapter-7/6.html#重写历史" class="xref">重写历史</a> 描述了重写历史与交互式暂存文件的若干有用的 Git 技巧——在将工作发送给其他人前使用这些工具来帮助生成一个干净又易懂的历史。</p> <p>最后一件要牢记的事是提交信息。
有一个创建优质提交信息的习惯会使 Git 的使用与协作容易的多。
一般情况下，信息应当以少于 50 个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更详细的解释。
Git 项目要求一个更详细的解释，包括做改动的动机和它的实现与之前行为的对比——这是一个值得遵循的好规则。
使用指令式的语气来编写提交信息，比如使用“Fix bug”而非“Fixed bug”或“Fixes bug”。
这里是一份 <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" class="link">最初由 Tim Pope 写的模板</a>：</p> <pre class="source language-text"><code>首字母大写的摘要（不多于 50 个字符）

如果必要的话，加入更详细的解释文字。在大概 72 个字符的时候换行。
在某些情形下，第一行被当作一封电子邮件的标题，剩下的文本作为正文。
分隔摘要与正文的空行是必须的（除非你完全省略正文），
如果你将两者混在一起，那么类似变基等工具无法正常工作。

使用指令式的语气来编写提交信息：使用“Fix bug”而非“Fixed bug”或“Fixes bug”。
此约定与 git merge 和 git revert 命令生成提交说明相同。

空行接着更进一步的段落。

- 标号也是可以的。

- 项目符号可以使用典型的连字符或星号，后跟一个空格，行之间用空行隔开，
  但是可以依据不同的惯例有所不同。

- 使用悬挂式缩进</code></pre> <p>如果你所有的提交信息都遵循此模版，那么对你和与你协作的其他开发者来说事情会变得非常容易。
Git 项目有一个良好格式化的提交信息——尝试在那儿运行 <code class="literal">git log --no-merges</code>
来看看漂亮的格式化的项目提交历史像什么样。</p> <aside title="Note: 按我们说的去做，不要照着我们做的去做。" epub:type="note" class="admonition note custom-block tip"><p class="custom-block-title">提示</p> <h2>按我们说的去做，不要照着我们做的去做。</h2> <div class="content"><p>为简单起见，本书中很多例子的提交说明并没有遵循这样良好的格式，
我们只是对 <code class="literal">git commit</code> 使用了 <code class="literal">-m</code> 选项。</p> <p>简而言之，按我们说的去做，不要照着我们做的去做。</p></div></aside> <h2 id="私有小型团队"><a href="#私有小型团队" class="header-anchor">#</a> 私有小型团队</h2> <p>
你可能会遇到的最简单的配置是有一两个其他开发者的私有项目。
“私有” 在这个上下文中，意味着闭源——不可以从外面的世界中访问到。
你和其他的开发者都有仓库的推送权限。</p> <p>在这个环境下，可以采用一个类似使用 Subversion 或其他集中式的系统时会使用的工作流程。
依然可以得到像离线提交、非常容易地新建分支与合并分支等高级功能，但是工作流程可以是很简单的；主要的区别是合并发生在客户端这边而不是在提交时发生在服务器那边。
让我们看看当两个开发者在一个共享仓库中一起工作时会是什么样子。
第一个开发者，John，克隆了仓库，做了改动，然后本地提交。
（为了缩短这些例子长度，协议信息已被替换为 <code class="literal">...</code>。）</p> <pre class="language-bash"><code><span style="font-weight:bold;">#</span> John<span style="border:1px solid #FF0000;">'</span>s Machine
<span style="font-weight:bold;">$</span> git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
<span style="font-weight:bold;">$</span> cd simplegit/
<span style="font-weight:bold;">$</span> vim lib/simplegit.rb
<span style="font-weight:bold;">$</span> git commit -am <span style="font-style:italic;">'remove invalid default value'</span>
[master 738ee87] remove invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre> <p>第二个开发者，Jessica，做了同样的事情——克隆仓库并提交了一个改动：</p> <pre class="language-bash"><code><span style="font-weight:bold;">#</span> Jessica<span style="border:1px solid #FF0000;">'</span>s Machine
<span style="font-weight:bold;">$</span> git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
<span style="font-weight:bold;">$</span> cd simplegit/
<span style="font-weight:bold;">$</span> vim TODO
<span style="font-weight:bold;">$</span> git commit -am <span style="font-style:italic;">'add reset task'</span>
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre> <p>现在，Jessica 把她的工作推送到服务器上，一切正常：</p> <pre class="language-bash"><code><span style="font-weight:bold;">#</span> Jessica<span style="border:1px solid #FF0000;">'</span>s Machine
<span style="font-weight:bold;">$</span> git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master</code></pre> <p>The last line of the output above shows a useful return message from the push operation.
The basic format is <code class="literal">&lt;oldref&gt;..&lt;newref&gt; fromref -&gt; toref</code>, where <code class="literal">oldref</code> means the old reference, <code class="literal">newref</code> means the new reference, <code class="literal">fromref</code> is the name of the local reference being pushed, and <code class="literal">toref</code> is the name of the remote reference being updated.
You’ll see similar output like this below in the discussions, so having a basic idea of the meaning will help in understanding the various states of the repositories.
More details are available in the documentation for <a href="https://git-scm.com/docs/git-push" class="link">git-push</a>.</p> <p>John 稍候也做了些改动，将它们提交到了本地仓库中，然后试着将它们推送到同一个服务器：</p> <pre class="language-bash"><code><span style="font-weight:bold;">#</span> John<span style="border:1px solid #FF0000;">'</span>s Machine
<span style="font-weight:bold;">$</span> git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'</code></pre> <p>这时 John 会推送失败，因为之前 Jessica 已经推送了她的更改。
如果之前习惯于用 Subversion 那么理解这点特别重要，因为你会注意到两个开发者并没有编辑同一个文件。
尽管 Subversion 会对编辑的不同文件在服务器上自动进行一次合并，但 Git 要求你先在本地合并提交。
换言之，John 必须先抓取 Jessica 的上游改动并将它们合并到自己的本地仓库中，才能被允许推送。</p> <p>第一步，John 抓取 Jessica 的工作（这只会 <strong>抓取</strong> Jessica 的上游工作，并不会将它合并到 John 的工作中）：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master</code></pre> <p>在这个时候，John 的本地仓库看起来像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/small-team-1.09ada785.png" alt="John 的分叉历史。"></div> <figcaption>Figure 5. John 的分叉历史</figcaption></figure> <p>现在 John 可以将抓取下来的 Jessica 的工作合并到他自己的本地工作中了：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git merge origin/master
Merge made by the 'recursive' strategy.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre> <p>合并进行得很顺利——John 更新后的历史现在看起来像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/small-team-2.6779b03f.png" alt="合并了 `origin/master` 之后 John 的仓库。"></div> <figcaption>Figure 6. 合并了 <code class="literal">origin/master</code> 之后 John 的仓库</figcaption></figure> <p>此时，John 可能想要测试新的代码，以确保 Jessica 的工作没有影响他自己的工作，
当一切正常后，他就能将新合并的工作推送到服务器了：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master</code></pre> <p>最终，John 的提交历史看起来像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/small-team-3.9928e1b1.png" alt="推送到 `origin` 服务器后 John 的历史。"></div> <figcaption>Figure 7. 推送到 <code class="literal">origin</code> 服务器后 John 的历史</figcaption></figure> <p>在此期间，Jessica 新建了一个名为 <code class="literal">issue54</code> 的主题分支，然后在该分支上提交了三次。
她还没有抓取 John 的改动，所以她的提交历史看起来像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/small-team-4.8fc06eda.png" alt="Jessica 的主题分支。"></div> <figcaption>Figure 8. Jessica 的主题分支</figcaption></figure> <p>忽然，Jessica 发现 John 向服务器推送了一些新的工作，她想要看一下，
于是就抓取了所有服务器上的新内容：</p> <pre class="language-bash"><code><span style="font-weight:bold;">#</span> Jessica<span style="border:1px solid #FF0000;">'</span>s Machine
<span style="font-weight:bold;">$</span> git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master</code></pre> <p>那会同时拉取 John 推送的工作。
Jessica 的历史现在看起来像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/small-team-5.4dbe0374.png" alt="抓取 John 的改动后 Jessica 的历史。"></div> <figcaption>Figure 9. 抓取 John 的改动后 Jessica 的历史</figcaption></figure> <p>Jessica 认为她的主题分支已经准备好了，但她像知道需要将 John 工作的哪些合并到自己的工作中才能推送。
她运行 <code class="literal">git log</code> 找了出来：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

   remove invalid default value</code></pre> <p><code class="literal">issue54..origin/master</code> 语法是一个日志过滤器，要求 Git 只显示所有在后面分支
（在本例中是 <code class="literal">origin/master</code>）但不在前面分支（在本例中是 <code class="literal">issue54</code>）的提交的列表。
我们将会在 <a id="xref--ch07-git-tools--_commit_ranges" href="/chapter-7/1.html#提交区间" class="xref">提交区间</a> 中详细介绍这个语法。</p> <p>目前，我们可以从输出中看到有一个 John 生成的但是 Jessica 还没有合并的提交。
如果她合并 <code class="literal">origin/master</code>，也就是说将会修改她的本地工作的那个单个提交。</p> <p>现在，Jessica 可以合并她的特性工作到她的 master 分支，
合并 John 的工作（<code class="literal">origin/master</code>）进入她的 <code class="literal">master</code> 分支，然后再次推送回服务器。</p> <p>首先（在已经提交了所有 <code class="literal">issue54</code> 主题分支上的工作后），为了整合所有这些工作，
她切换回她的 master 分支。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.</code></pre> <p>Jessica 既可以先合并 <code class="literal">origin/master</code> 也可以先合并 <code class="literal">issue54</code> ——它们都是上游，所以顺序并没有关系。
不论她选择的顺序是什么最终的结果快照是完全一样的；只是历史会稍微有些不同。
她选择先合并 <code class="literal">issue54</code>：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)</code></pre> <p>没有发生问题，如你所见它是一次简单的快进合并。
现在 Jessica 在本地合并了 <code class="literal">origin/master</code> 分支上 John 之前抓取的工作：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre> <p>每一个文件都干净地合并了，Jessica 的历史现在看起来像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/small-team-6.8c3cb756.png" alt="合并了 John 的改动后 Jessica 的历史。"></div> <figcaption>Figure 10. 合并了 John 的改动后 Jessica 的历史</figcaption></figure> <p>现在 <code class="literal">origin/master</code> 是可以从 Jessica 的 <code class="literal">master</code> 分支到达的，
所以她应该可以成功地推送（假设同一时间 John 并没有更多推送）：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master</code></pre> <p>每一个开发者都提交了几次并成功地合并了其他人的工作。</p> <figure class="image"><div class="content"><img src="/assets/img/small-team-7.b7f076ab.png" alt="推送所有的改动回服务器后 Jessica 的历史。"></div> <figcaption>Figure 11. 推送所有的改动回服务器后 Jessica 的历史</figcaption></figure> <p>这是一个最简单的工作流程。
你通常会在一个主题分支上工作一会儿，当它准备好整合时就合并到你的 <code class="literal">master</code> 分支。
当想要共享工作时，如果有改动的话就抓取它然后合并到你自己的 <code class="literal">master</code> 分支，
之后推送到服务器上的 <code class="literal">master</code> 分支。通常顺序像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/small-team-flow.489f1dae.png" alt="一个简单的多人 Git 工作流程的通常事件顺序。"></div> <figcaption>Figure 12. 一个简单的多人 Git 工作流程的通常事件顺序</figcaption></figure> <h2 id="私有管理团队"><a href="#私有管理团队" class="header-anchor">#</a> 私有管理团队</h2> <p>
在接下来的场景中，你会看到大型私有团队中贡献者的角色。
你将学到如何在这种工作环境中工作，其中小组基于特性进行协作，而这些团队的贡献将会由其他人整合。</p> <p>让我们假设 John 与 Jessica 在一个特性（<code class="literal">featureA</code>）上工作，
同时 Jessica 与第三个开发者 Josie 在第二个特性（<code class="literal">featureB</code>）上工作。
在本例中，公司使用了一种整合-管理者工作流程，独立小组的工作只能被特定的工程师整合，
主仓库的 <code class="literal">master</code> 分支只能被那些工程师更新。
在这种情况下，所有的工作都是在基于团队的分支上完成的并且稍后会被整合者拉到一起。</p> <p>因为 Jessica 在两个特性上工作，并且平行地与两个不同的开发者协作，让我们跟随她的工作流程。
假设她已经克隆了仓库，首先决定在 <code class="literal">featureA</code> 上工作。
她为那个特性创建了一个新分支然后在那做了一些工作：</p> <pre class="language-bash"><code><span style="font-weight:bold;">#</span> Jessica<span style="border:1px solid #FF0000;">'</span>s Machine
<span style="font-weight:bold;">$</span> git checkout -b featureA
Switched to a new branch 'featureA'
<span style="font-weight:bold;">$</span> vim lib/simplegit.rb
<span style="font-weight:bold;">$</span> git commit -am <span style="font-style:italic;">'add limit to log function'</span>
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre> <p>在这个时候，她需要将工作共享给 John，所以她推送了 <code class="literal">featureA</code> 分支的提交到服务器上。
Jessica 没有 <code class="literal">master</code> 分支的推送权限——只有整合者有——所以为了与 John 协作必须推送另一个分支。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA</code></pre> <p>Jessica 向 John 发邮件告诉他已经推送了一些工作到 <code class="literal">featureA</code> 分支现在可以看一看。
当她等待 John 的反馈时，Jessica 决定与 Josie 开始在 <code class="literal">featureB</code> 上工作。
为了开始工作，她基于服务器的 <code class="literal">master</code> 分支开始了一个新分支。</p> <pre class="language-bash"><code><span style="font-weight:bold;">#</span> Jessica<span style="border:1px solid #FF0000;">'</span>s Machine
<span style="font-weight:bold;">$</span> git fetch origin
<span style="font-weight:bold;">$</span> git checkout -b featureB origin/master
Switched to a new branch 'featureB'</code></pre> <p>现在，Jessica 在 <code class="literal">featureB</code> 分支上创建了几次提交：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> vim lib/simplegit.rb
<span style="font-weight:bold;">$</span> git commit -am <span style="font-style:italic;">'made the ls-tree function recursive'</span>
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
<span style="font-weight:bold;">$</span> vim lib/simplegit.rb
<span style="font-weight:bold;">$</span> git commit -am <span style="font-style:italic;">'add ls-files'</span>
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)</code></pre> <p>现在 Jessica 的仓库看起来像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/managed-team-1.85db660f.png" alt="Jessica 的初始提交历史。"></div> <figcaption>Figure 13. Jessica 的初始提交历史</figcaption></figure> <p>她准备好推送工作了，但是一封来自 Josie 的邮件告知一些初始的“featureB”
工作已经被推送到服务器的 <code class="literal">featureBee</code> 上了。
Jessica 在能够将她的工作推送到服务器前，需要将那些改动与她自己的合并。
她首先通过 <code class="literal">git fetch</code> 抓取了 Josie 的改动：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee</code></pre> <p>假设 Jessica 还在她检出的 <code class="literal">featureB</code> 分支上，现在可以通过 <code class="literal">git merge</code> 将其合并到她做的工作中了：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)</code></pre> <p>此时，Jessica 想要将所有合并后的“featureB”推送会服务器，，但她并不想直接推送她自己的 <code class="literal">featureB</code> 分支。
由于 Josie 已经开启了一个上游的 <code class="literal">featureBee</code> 分支，因此 Jessica 想要推送到 <strong>这个</strong> 分支上，于是她这样做：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee</code></pre> <p>这称作一个 <em>引用规范</em>。
查看 <a id="xref--ch10-git-internals--_refspec" href="/chapter-10/5.html#引用规范" class="xref">引用规范</a> 了解关于 Git 引用规范与通过它们可以做的不同的事情的详细讨论。
也要注意 <code class="literal">-u</code> 标记；这是 <code class="literal">--set-upstream</code> 的简写，该标记会为之后轻松地推送与拉取配置分支。</p> <p>紧接着，John 发邮件给 Jessica 说他已经推送了一些改动到 <code class="literal">featureA</code> 分支并要求她去验证它们。
她运行一个 <code class="literal">git fetch</code> 来拉取下那些改动：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA</code></pre> <p>Jessica 通过比较新抓取的 <code class="literal">featureA</code> 分支和她同一分支的本地副本，看到了 John 的新工作日志。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25</code></pre> <p>如果 Jessica 觉得可以，她就能将 John 的新工作合并到她本地的 <code class="literal">featureA</code> 分支上：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout featureA
Switched to branch 'featureA'
<span style="font-weight:bold;">$</span> git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)</code></pre> <p>最后，Jessica 可能想要对整个合并后的内容做一些小修改，
于是她将这些修改提交到了本地的 <code class="literal">featureA</code> 分支，接着将最终的结果推送回了服务器。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git commit -am <span style="font-style:italic;">'small tweak'</span>
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
<span style="font-weight:bold;">$</span> git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -&gt; featureA</code></pre> <p>Jessica 的提交历史现在看起来像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/managed-team-2.0332df17.png" alt="在一个主题分支提交后 Jessica 的历史。"></div> <figcaption>Figure 14. 在一个主题分支提交后 Jessica 的历史</figcaption></figure> <p>这时，Jessica、Josie 与 John 通知整合者服务器上的 <code class="literal">featureA</code> 与 <code class="literal">featureBee</code> 分支准备好整合到主线中了。
在整合者将这些分支合并到主线后，就能一次将这个新的合并提交抓取下来，历史看起来就会像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/managed-team-3.75c09490.png" alt="合并了 Jessica 的两个主题分支后她的历史。"></div> <figcaption>Figure 15. 合并了 Jessica 的两个主题分支后她的历史</figcaption></figure> <p>许多团队切换到 Git 就是看中了这种能让多个团队并行工作、并在之后合并不同工作的能力。
团队中更小一些的子小组可以通过远程分支协作而不必影响或妨碍整个团队的能力是 Git 的一个巨大优势。
在这儿看到的工作流程顺序类似这样：</p> <figure class="image"><div class="content"><img src="/assets/img/managed-team-flow.f8372e6f.png" alt="这种管理团队工作流程的基本顺序。"></div> <figcaption>Figure 16. 这种管理团队工作流程的基本顺序</figcaption></figure> <h2 id="派生的公开项目"><a href="#派生的公开项目" class="header-anchor">#</a> 派生的公开项目</h2> <p>
向公开项目做贡献有一点儿不同。
因为没有权限直接更新项目的分支，你必须用其他办法将工作给维护者。
第一个例子描述在支持简单派生的 Git 托管上使用派生来做贡献。
许多托管站点支持这个功能（包括 GitHub、BitBucket、repo.or.cz 等等），许多项目维护者期望这种风格的贡献。
下一节会讨论偏好通过邮件接受贡献补丁的项目。</p> <p>首先，你可能想要克隆主仓库，为计划贡献的补丁或补丁序列创建一个主题分支，然后在那儿做工作。
顺序看起来基本像这样：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git clone &lt;url&gt;
<span style="font-weight:bold;">$</span> cd project
<span style="font-weight:bold;">$</span> git checkout -b featureA
  ... work ...
<span style="font-weight:bold;">$</span> git commit
  ... work ...
<span style="font-weight:bold;">$</span> git commit</code></pre> <aside title="Note" epub:type="note" class="admonition note custom-block tip"><p class="custom-block-title">提示</p> <div class="content"><p>你可以用 <code class="literal">rebase -i</code> 将工作压缩成一个单独的提交，或者重排提交中的工作使补丁更容易被维护者审核——
查看 <a href="/chapter-7/6.html#重写历史" class="xref">重写历史</a> 了解关于交互式变基的更多信息。</p></div></aside> <p>当你的分支工作完成后准备将其贡献回维护者，去原始项目中然后点击“Fork”按钮，创建一份自己的可写的项目派生仓库。
然后需要在本地仓库中将该仓库添加为一个新的远程仓库，在本例中称作 <code class="literal">myfork</code>：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git remote add myfork &lt;url&gt;</code></pre> <p>然后需要推送工作到上面。
相对于合并到主分支再推送上去，推送你正在工作的主题分支到仓库上更简单。
原因是工作如果不被接受或者是被拣选的，就不必回退你的 master 分支
（拣选操作 <code class="literal">cherry-pick</code> 详见 <a id="xref-_rebase_cherry_pick" href="#_rebase_cherry_pick" class="xref">变基与拣选工作流</a>）。
如果维护者合并、变基或拣选你的工作，不管怎样你最终会通过拉取他们的仓库找回来你的工作。</p> <p>In any event, you can push your work with:</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git push -u myfork featureA</code></pre> <p>
当工作已经被推送到你的派生仓库后，你需要通知原项目的维护者你有想要他们合并的工作。
这通常被称作一个 <strong>拉取请求（Pull Request）</strong>，你通常可以通过网站生成它——
GitHub 有它自己的 Pull Request 机制，我们将会在 <a id="xref--ch06-github" href="/chapter-6/index.html" class="xref">GitHub</a>
介绍——也可以运行 <code class="literal">git request-pull</code> 命令然后手动地将输出发送电子邮件给项目的维护者。</p> <p><code class="literal">git request-pull</code> 命令接受一个要拉取主题分支的基础分支，以及它们要拉取的 Git 仓库的 URL，
产生一个请求拉取的所有修改的摘要。
例如，Jessica 想要发送给 John 一个拉取请求，她已经在刚刚推送的分支上做了两次提交。她可以运行这个：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
Jessica Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)</code></pre> <p>此输出可被发送给维护者——它告诉他们工作是从哪个分支开始的、提交的摘要、以及从哪里拉取这些工作。</p> <p>在一个你不是维护者的项目上，通常有一个总是跟踪 <code class="literal">origin/master</code> 的 <code class="literal">master</code> 分支会很方便，在主题分支上做工作是因为如果它们被拒绝时你可以轻松地丢弃。
如果同一时间主仓库移动了然后你的提交不再能干净地应用，那么使工作主题独立于主题分支也会使你变基（rebase）工作时更容易。
例如，你想要提供第二个特性工作到项目，不要继续在刚刚推送的主题分支上工作——从主仓库的 <code class="literal">master</code> 分支重新开始：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout -b featureB origin/master
  ... work ...
<span style="font-weight:bold;">$</span> git commit
<span style="font-weight:bold;">$</span> git push myfork featureB
<span style="font-weight:bold;">$</span> git request-pull origin/master myfork
  ... email generated request pull to maintainer ...
<span style="font-weight:bold;">$</span> git fetch origin</code></pre> <p>现在，每一个特性都保存在一个贮藏库中——类似于补丁队列——可以重写、变基与修改而不会让特性互相干涉或互相依赖，像这样：</p> <figure class="image"><div class="content"><img src="/assets/img/public-small-1.d8903b67.png" alt="`featureB` 的初始提交历史。"></div> <figcaption>Figure 17. <code class="literal">featureB</code> 的初始提交历史</figcaption></figure> <p>假设项目维护者已经拉取了一串其他补丁，然后尝试拉取你的第一个分支，但是没有干净地合并。
在这种情况下，可以尝试变基那个分支到 <code class="literal">origin/master</code> 的顶部，为维护者解决冲突，然后重新提交你的改动：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout featureA
<span style="font-weight:bold;">$</span> git rebase origin/master
<span style="font-weight:bold;">$</span> git push -f myfork featureA</code></pre> <p>这样会重写你的历史，现在看起来像是 <a id="xref-psp_b" href="#psp_b" class="xref"><code class="literal">featureA</code> 工作之后的提交历史</a></p> <figure id="psp_b" class="image"><div class="content"><img src="/assets/img/public-small-2.0bc39f1e.png" alt="`featureA` 工作之后的提交历史。"></div> <figcaption>Figure 18. <code class="literal">featureA</code> 工作之后的提交历史</figcaption></figure> <p>因为你将分支变基了，所以必须为推送命令指定 <code class="literal">-f</code> 选项，这样才能将服务器上有一个不是它的后代的提交的 <code class="literal">featureA</code> 分支替换掉。
一个替代的选项是推送这个新工作到服务器上的一个不同分支（可能称作 <code class="literal">featureAv2</code>）。</p> <p>让我们看一个更有可能的情况：维护者看到了你的第二个分支上的工作并且很喜欢其中的概念，但是想要你修改一下实现的细节。
你也可以利用这次机会将工作基于项目现在的 <code class="literal">master</code> 分支。
你从现在的 <code class="literal">origin/master</code> 分支开始一个新分支，在那儿压缩 <code class="literal">featureB</code> 的改动，解决任何冲突，改变实现，然后推送它为一个新分支。</p> <p></p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout -b featureBv2 origin/master
<span style="font-weight:bold;">$</span> git merge --squash featureB
  ... change implementation ...
<span style="font-weight:bold;">$</span> git commit
<span style="font-weight:bold;">$</span> git push myfork featureBv2</code></pre> <p><code class="literal">--squash</code> 选项接受被合并的分支上的所有工作，并将其压缩至一个变更集，
使仓库变成一个真正的合并发生的状态，而不会真的生成一个合并提交。
这意味着你的未来的提交将会只有一个父提交，并允许你引入另一个分支的所有改动，
然后在记录一个新提交前做更多的改动。同样 <code class="literal">--no-commit</code> 选项在默认合并过程中可以用来延迟生成合并提交。</p> <p>现在你可以给维护者发送一条消息，表示你已经做了要求的修改然后他们可以在你的 <code class="literal">featureBv2</code> 分支上找到那些改动。</p> <figure class="image"><div class="content"><img src="/assets/img/public-small-3.6d12cab1.png" alt="`featureBv2` 工作之后的提交历史。"></div> <figcaption>Figure 19. <code class="literal">featureBv2</code> 工作之后的提交历史</figcaption></figure> <h2 id="通过邮件的公开项目"><a href="#通过邮件的公开项目" class="header-anchor">#</a> 通过邮件的公开项目</h2> <p>
许多项目建立了接受补丁的流程——需要检查每一个项目的特定规则，因为它们之间有区别。
因为有几个历史悠久的、大型的项目会通过一个开发者的邮件列表接受补丁，现在我们将会通过一个例子来演示。</p> <p>工作流程与之前的用例是类似的——你为工作的每一个补丁序列创建主题分支。
区别是如何提交它们到项目中。
生成每一个提交序列的电子邮件版本然后邮寄它们到开发者邮件列表，而不是派生项目然后推送到你自己的可写版本。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout -b topicA
  ... work ...
<span style="font-weight:bold;">$</span> git commit
  ... work ...
<span style="font-weight:bold;">$</span> git commit</code></pre> <p>
现在有两个提交要发送到邮件列表。
使用 <code class="literal">git format-patch</code> 来生成可以邮寄到列表的 mbox 格式的文件——它将每一个提交转换为一封电子邮件，提交信息的第一行作为主题，剩余信息与提交引入的补丁作为正文。
它有一个好处是使用 <code class="literal">format-patch</code> 生成的一封电子邮件应用的提交正确地保留了所有的提交信息。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch</code></pre> <p><code class="literal">format-patch</code> 命令打印出它创建的补丁文件名字。
<code class="literal">-M</code> 开关告诉 Git 查找重命名。
文件最后看起来像这样：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command(&quot;git log #{treeish}&quot;)
+    command(&quot;git log -n 20 #{treeish}&quot;)
   end

   def ls_tree(treeish = 'master')
--
2.1.0</code></pre> <p>也可以编辑这些补丁文件为邮件列表添加更多不想要在提交信息中显示出来的信息。
如果在 <code class="literal">---</code> 行与补丁开头（<code class="literal">diff --git</code> 行）之间添加文本，那么开发者就可以阅读它，但是应用补丁时会忽略它。</p> <p>为了将其邮寄到邮件列表，你既可以将文件粘贴进电子邮件客户端，也可以通过命令行程序发送它。
粘贴文本经常会发生格式化问题，特别是那些不会合适地保留换行符与其他空白的 “更聪明的” 客户端。
幸运的是，Git 提供了一个工具帮助你通过 IMAP 发送正确格式化的补丁，这可能对你更容易些。
我们将会演示如何通过 Gmail 发送一个补丁，它正好是我们所知最好的邮件代理；可以在之前提到的 Git 源代码中的 <code class="literal">Documentation/SubmittingPatches</code> 文件的最下面了解一系列邮件程序的详细指令。</p> <p>
首先，需要在 <code class="literal">~/.gitconfig</code> 文件中设置 imap 区块。
可以通过一系列的 <code class="literal">git config</code> 命令来分别设置每一个值，或者手动添加它们，不管怎样最后配置文件应该看起来像这样：</p> <pre class="source language-ini"><code><span style="font-weight:bold;">[imap]</span>
  folder = <span style="font-style:italic;">&quot;[Gmail]/Drafts&quot;</span>
<span style="font-style:italic;">  host = imaps://imap.gmail.com</span>
<span style="font-style:italic;">  user = user@gmail.com</span>
<span style="font-style:italic;">  pass = YX]8g76G_2^sFbd</span>
<span style="font-style:italic;">  port = 993</span>
<span style="font-style:italic;">  sslverify = false</span></code></pre> <p>如果 IMAP 服务器不使用 SSL，最后两行可能没有必要，host 的值会是 <code class="literal">imap://</code> 而不是 <code class="literal">imaps://</code>。
当那些设置完成后，可以使用 <code class="literal">git imap-send</code> 将补丁序列放在特定 IMAP 服务器的 Drafts 文件夹中：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done</code></pre> <p>此时，你可以到 Drafts 文件夹中，修改收件人字段为想要发送补丁的邮件列表，
可能需要抄送给维护者或负责那个部分的人，然后发送。</p> <p>你也可以通过一个 SMTP 服务器发送补丁。
同之前一样，你可以通过一系列的 <code class="literal">git config</code> 命令来分别设置选项，
或者你可以手动地将它们添加到你的 <code class="literal">~/.gitconfig</code> 文件的 sendmail 区块：</p> <pre class="source language-ini"><code><span style="font-weight:bold;">[sendemail]</span>
  smtpencryption = <span style="font-style:italic;">tls</span>
<span style="font-style:italic;">  smtpserver = smtp.gmail.com</span>
<span style="font-style:italic;">  smtpuser = user@gmail.com</span>
<span style="font-style:italic;">  smtpserverport = 587</span></code></pre> <p>当这完成后，你可以使用 <code class="literal">git send-email</code> 发送你的补丁：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y</code></pre> <p>然后，对于正在发送的每一个补丁，Git 会吐出这样的一串日志信息：</p> <pre class="source language-text"><code>(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
  \line 'From: Jessica Smith &lt;jessica@example.com&gt;'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK</code></pre> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>这个部分介绍了处理可能会遇到的几个迥然不同类型的 Git 项目的一些常见的工作流程，
介绍了帮助管理这个过程的一些新工具。
接下来，你会了解到如何在贡献的另一面工作：维护一个 Git 项目。
你将会学习如何成为一个仁慈的独裁者或整合管理者。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/chapter-5/1.html" class="prev">
        分布式工作流程
      </a></span> <span class="next"><a href="/chapter-5/3.html">
        维护项目
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e343c26e.js" defer></script><script src="/assets/js/2.c0327591.js" defer></script><script src="/assets/js/5.b1d6f09c.js" defer></script>
  </body>
</html>
