(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{485:function(a,e,t){"use strict";t.r(e);var s=t(28),c=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"传输协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#传输协议"}},[a._v("#")]),a._v(" 传输协议")]),a._v(" "),t("p",[a._v("Git 可以通过两种主要的方式在版本库之间传输数据：“哑（dumb）”协议和“智能（smart）”协议。\n本节将会带你快速浏览这两种协议的运作方式。")]),a._v(" "),t("h2",{attrs:{id:"哑协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哑协议"}},[a._v("#")]),a._v(" 哑协议")]),a._v(" "),t("p",[a._v("如果你正在架设一个基于 HTTP 协议的只读版本库，一般而言这种情况下使用的就是哑协议。\n这个协议之所以被称为“哑”协议，是因为在传输过程中，服务端不需要有针对 Git 特有的代码；抓取过程是一系列 HTTP 的 "),t("code",{staticClass:"literal"},[a._v("GET")]),a._v(" 请求，这种情况下，客户端可以推断出服务端 Git 仓库的布局。")]),a._v(" "),t("aside",{staticClass:"admonition note custom-block tip",attrs:{title:"Note","epub:type":"note"}},[t("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),t("div",{staticClass:"content"},[t("p",[a._v("现在已经很少使用哑协议了。\n使用哑协议的版本库很难保证安全性和私有化，所以大多数 Git 服务器宿主（包括云端和本地）都会拒绝使用它。\n一般情况下都建议使用智能协议，我们会在后面进行介绍。")])])]),a._v(" "),t("p",[a._v("让我们通过 simplegit 版本库来看看 "),t("code",{staticClass:"literal"},[a._v("http-fetch")]),a._v(" 的过程：")]),a._v(" "),t("pre",{staticClass:"language-bash"},[t("code",[t("span",{staticStyle:{"font-weight":"bold"}},[a._v("$")]),a._v(" git clone http://server/simplegit-progit.git")])]),a._v(" "),t("p",[a._v("它做的第一件事就是拉取 "),t("code",{staticClass:"literal"},[a._v("info/refs")]),a._v(" 文件。\n这个文件是通过 "),t("code",{staticClass:"literal"},[a._v("update-server-info")]),a._v(" 命令生成的，这也解释了在使用 HTTP 传输时，必须把它设置为 "),t("code",{staticClass:"literal"},[a._v("post-receive")]),a._v(" 钩子的原因：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET info/refs\nca82a6dff817ec66f44342007202690a93763949     refs/heads/master")])]),a._v(" "),t("p",[a._v("现在，你得到了一个远程引用和 SHA-1 值的列表。\n接下来，你要确定 HEAD 引用是什么，这样你就知道在完成后应该被检出到工作目录的内容：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET HEAD\nref: refs/heads/master")])]),a._v(" "),t("p",[a._v("这说明在完成抓取后，你需要检出 "),t("code",{staticClass:"literal"},[a._v("master")]),a._v(" 分支。\n这时，你就可以开始遍历处理了。\n因为你是从 "),t("code",{staticClass:"literal"},[a._v("info/refs")]),a._v(" 文件中所提到的 "),t("code",{staticClass:"literal"},[a._v("ca82a6")]),a._v(" 提交对象开始的，所以你的首要操作是获取它：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET objects/ca/82a6dff817ec66f44342007202690a93763949\n(179 bytes of binary data)")])]),a._v(" "),t("p",[a._v("你取回了一个对象——这是一个在服务端以松散格式保存的对象，是你通过使用静态 HTTP GET 请求获取的。\n你可以使用 zlib 解压缩它，去除其头部，查看提交记录的内容：")]),a._v(" "),t("pre",{staticClass:"language-bash"},[t("code",[t("span",{staticStyle:{"font-weight":"bold"}},[a._v("$")]),a._v(" git cat-file -p ca82a6dff817ec66f44342007202690a93763949\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nparent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\nauthor Scott Chacon <schacon@gmail.com> 1205815931 -0700\ncommitter Scott Chacon <schacon@gmail.com> 1240030591 -0700\n\nchanged the version number")])]),a._v(" "),t("p",[a._v("接下来，你还要再获取两个对象，一个是树对象 "),t("code",{staticClass:"literal"},[a._v("cfda3b")]),a._v("，它包含有我们刚刚获取的提交对象所指向的内容，另一个是它的父提交 "),t("code",{staticClass:"literal"},[a._v("085bb3")]),a._v("：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n(179 bytes of data)")])]),a._v(" "),t("p",[a._v("这样就取得了你的下一个提交对象。\n再抓取树对象：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf\n(404 - Not Found)")])]),a._v(" "),t("p",[a._v("噢——看起来这个树对象在服务端并不以松散格式对象存在，所以你得到了一个 404 响应，代表在 HTTP 服务端没有找到该对象。\n这有好几个可能的原因——这个对象可能在替代版本库里面，或者在包文件里面。\nGit 会首先检查所有列出的替代版本库：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET objects/info/http-alternates\n(empty file)")])]),a._v(" "),t("p",[a._v("如果这返回了一个包含替代版本库 URL 的列表，那么 Git 就会去那些地址检查松散格式对象和文件——这是一种能让派生项目共享对象以节省磁盘的好方法。\n然而，在这个例子中，没有列出可用的替代版本库。所以你所需要的对象肯定在某个包文件中。\n要检查服务端有哪些可用的包文件，你需要获取 "),t("code",{staticClass:"literal"},[a._v("objects/info/packs")]),a._v(" 文件，这里面有一个包文件列表（它也是通过执行 "),t("code",{staticClass:"literal"},[a._v("update-server-info")]),a._v(" 所生成的）：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET objects/info/packs\nP pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack")])]),a._v(" "),t("p",[a._v("服务端只有一个包文件，所以你要的对象显然就在里面。但是你要先检查它的索引文件以确认。\n即使服务端有多个包文件，这也是很有用的，因为这样你就可以知道你所需要的对象是在哪一个包文件里面：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx\n(4k of binary data)")])]),a._v(" "),t("p",[a._v("现在你有这个包文件的索引，你可以查看你要的对象是否在里面——\n因为索引文件列出了这个包文件所包含的所有对象的 SHA-1 值，和该对象存在于包文件中的偏移量。\n你的对象就在这里，接下来就是获取整个包文件：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack\n(13k of binary data)")])]),a._v(" "),t("p",[a._v("现在你也有了你的树对象，你可以继续在提交记录上漫游。\n它们全部都在这个你刚下载的包文件里面，所以你不用继续向服务端请求更多下载了。\nGit 会将开始时下载的 HEAD 引用所指向的 "),t("code",{staticClass:"literal"},[a._v("master")]),a._v(" 分支检出到工作目录。")]),a._v(" "),t("h2",{attrs:{id:"智能协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#智能协议"}},[a._v("#")]),a._v(" 智能协议")]),a._v(" "),t("p",[a._v("哑协议虽然很简单但效率略低，且它不能从客户端向服务端发送数据。\n智能协议是更常用的传送数据的方法，但它需要在服务端运行一个进程，而这也是 Git 的智能之处——它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。\n总共有两组进程用于传输数据，它们分别负责上传和下载数据。")]),a._v(" "),t("h3",{attrs:{id:"上传数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#上传数据"}},[a._v("#")]),a._v(" 上传数据")]),a._v(" "),t("p",[a._v("\n为了上传数据至远端，Git 使用 "),t("code",{staticClass:"literal"},[a._v("send-pack")]),a._v(" 和 "),t("code",{staticClass:"literal"},[a._v("receive-pack")]),a._v(" 进程。\n运行在客户端上的 "),t("code",{staticClass:"literal"},[a._v("send-pack")]),a._v(" 进程连接到远端运行的 "),t("code",{staticClass:"literal"},[a._v("receive-pack")]),a._v(" 进程。")]),a._v(" "),t("h4",{attrs:{id:"ssh"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ssh"}},[a._v("#")]),a._v(" SSH")]),a._v(" "),t("p",[a._v("举例来说，在项目中使用命令 "),t("code",{staticClass:"literal"},[a._v("git push origin master")]),a._v(" 时, "),t("code",{staticClass:"literal"},[a._v("origin")]),a._v(" 是由基于 SSH 协议的 URL 所定义的。\nGit 会运行 "),t("code",{staticClass:"literal"},[a._v("send-pack")]),a._v(" 进程，它会通过 SSH 连接你的服务器。\n它会尝试通过 SSH 在服务端执行命令，就像这样：")]),a._v(" "),t("pre",{staticClass:"language-bash"},[t("code",[t("span",{staticStyle:{"font-weight":"bold"}},[a._v("$")]),a._v(" ssh -x git@server "),t("span",{staticStyle:{"font-style":"italic"}},[a._v("\"git-receive-pack 'simplegit-progit.git'\"")]),a._v("\n00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \\\n\tdelete-refs side-band-64k quiet ofs-delta \\\n\tagent=git/2:2.1.1+github-607-gfba4028 delete-refs\n0000")])]),a._v(" "),t("p",[t("code",{staticClass:"literal"},[a._v("git-receive-pack")]),a._v(" 命令会立即为它所拥有的每一个引用发送一行响应——在这个例子中，就只有 "),t("code",{staticClass:"literal"},[a._v("master")]),a._v(" 分支和它的 SHA-1 值。\n第一行响应中也包含了一个服务端能力的列表（这里是 "),t("code",{staticClass:"literal"},[a._v("report-status")]),a._v("、"),t("code",{staticClass:"literal"},[a._v("delete-refs")]),a._v(" 和一些其它的，包括客户端的识别码）。")]),a._v(" "),t("p",[a._v("每一行以一个四位的十六进制值开始，用于指明本行的长度。\n你看到第一行以 00a5 开始，这在十六进制中表示 165，意味着第一行有 165 字节。\n下一行是 0000，表示服务端已完成了发送引用列表过程。")]),a._v(" "),t("p",[a._v("现在它知道了服务端的状态，你的 "),t("code",{staticClass:"literal"},[a._v("send-pack")]),a._v(" 进程会判断哪些提交记录是它所拥有但服务端没有的。\n"),t("code",{staticClass:"literal"},[a._v("send-pack")]),a._v(" 会告知 "),t("code",{staticClass:"literal"},[a._v("receive-pack")]),a._v(" 这次推送将会更新的各个引用。\n举个例子，如果你正在更新 "),t("code",{staticClass:"literal"},[a._v("master")]),a._v(" 分支，并且增加 "),t("code",{staticClass:"literal"},[a._v("experiment")]),a._v(" 分支，这个 "),t("code",{staticClass:"literal"},[a._v("send-pack")]),a._v(" 的响应将会是像这样：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \\\n\trefs/heads/master report-status\n006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \\\n\trefs/heads/experiment\n0000")])]),a._v(" "),t("p",[a._v("第一行也包括了客户端的能力。\n这里的全为 "),t("em",[a._v("0")]),a._v(" 的 SHA-1 值表示之前没有过这个引用——因为你正要添加新的 experiment 引用。\n删除引用时，将会看到相反的情况：右边的 SHA-1 值全为 "),t("em",[a._v("0")]),a._v("。")]),a._v(" "),t("p",[a._v("连接是从下面这个请求开始的：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack\n001f# service=git-receive-pack\n00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master report-status \\\n\tdelete-refs side-band-64k quiet ofs-delta \\\n\tagent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e\n0000")])]),a._v(" "),t("p",[a._v("这完成了客户端和服务端的第一次数据交换。\n接下来客户端发起另一个请求，这次是一个 "),t("code",{staticClass:"literal"},[a._v("POST")]),a._v(" 请求，这个请求中包含了 "),t("code",{staticClass:"literal"},[a._v("send-pack")]),a._v(" 提供的数据。")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> POST http://server/simplegit-progit.git/git-receive-pack")])]),a._v(" "),t("p",[a._v("这个 "),t("code",{staticClass:"literal"},[a._v("POST")]),a._v(" 请求的内容是 "),t("code",{staticClass:"literal"},[a._v("send-pack")]),a._v(" 的输出和相应的包文件。\n服务端在收到请求后相应地作出成功或失败的 HTTP 响应。")]),a._v(" "),t("h3",{attrs:{id:"下载数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#下载数据"}},[a._v("#")]),a._v(" 下载数据")]),a._v(" "),t("p",[a._v("\n当你在下载数据时， "),t("code",{staticClass:"literal"},[a._v("fetch-pack")]),a._v(" 和 "),t("code",{staticClass:"literal"},[a._v("upload-pack")]),a._v(" 进程就起作用了。\n客户端启动 "),t("code",{staticClass:"literal"},[a._v("fetch-pack")]),a._v(" 进程，连接至远端的 "),t("code",{staticClass:"literal"},[a._v("upload-pack")]),a._v(" 进程，以协商后续传输的数据。")]),a._v(" "),t("h4",{attrs:{id:"ssh-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ssh-2"}},[a._v("#")]),a._v(" SSH")]),a._v(" "),t("p",[a._v("如果你通过 SSH 使用抓取功能，"),t("code",{staticClass:"literal"},[a._v("fetch-pack")]),a._v(" 会像这样运行：")]),a._v(" "),t("pre",{staticClass:"language-bash"},[t("code",[t("span",{staticStyle:{"font-weight":"bold"}},[a._v("$")]),a._v(" ssh -x git@server "),t("span",{staticStyle:{"font-style":"italic"}},[a._v("\"git-upload-pack 'simplegit-progit.git'\"")])])]),a._v(" "),t("p",[a._v("在 "),t("code",{staticClass:"literal"},[a._v("fetch-pack")]),a._v(" 连接后，"),t("code",{staticClass:"literal"},[a._v("upload-pack")]),a._v(" 会返回类似下面的内容：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("00dfca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \\\n\tside-band side-band-64k ofs-delta shallow no-progress include-tag \\\n\tmulti_ack_detailed symref=HEAD:refs/heads/master \\\n\tagent=git/2:2.1.1+github-607-gfba4028\n003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master\n0000")])]),a._v(" "),t("p",[a._v("这与 "),t("code",{staticClass:"literal"},[a._v("receive-pack")]),a._v(" 的响应很相似，但是这里所包含的能力是不同的。\n而且它还包含 HEAD 引用所指向内容（"),t("code",{staticClass:"literal"},[a._v("symref=HEAD:refs/heads/master")]),a._v("），这样如果客户端执行的是克隆，它就会知道要检出什么。")]),a._v(" "),t("p",[a._v("这时候，"),t("code",{staticClass:"literal"},[a._v("fetch-pack")]),a._v(" 进程查看它自己所拥有的对象，并响应 “want” 和它需要的对象的 SHA-1 值。\n它还会发送“have”和所有它已拥有的对象的 SHA-1 值。\n在列表的最后，它还会发送“done”以通知 "),t("code",{staticClass:"literal"},[a._v("upload-pack")]),a._v(" 进程可以开始发送它所需对象的包文件：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta\n0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\n0009done\n0000")])]),a._v(" "),t("h4",{attrs:{id:"http-s"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-s"}},[a._v("#")]),a._v(" HTTP(S)")]),a._v(" "),t("p",[a._v("抓取操作的握手需要两个 HTTP 请求。\n第一个是向和哑协议中相同的端点发送 "),t("code",{staticClass:"literal"},[a._v("GET")]),a._v(" 请求：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> GET $GIT_URL/info/refs?service=git-upload-pack\n001e# service=git-upload-pack\n00e7ca82a6dff817ec66f44342007202690a93763949 HEAD multi_ack thin-pack \\\n\tside-band side-band-64k ofs-delta shallow no-progress include-tag \\\n\tmulti_ack_detailed no-done symref=HEAD:refs/heads/master \\\n\tagent=git/2:2.1.1+github-607-gfba4028\n003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master\n0000")])]),a._v(" "),t("p",[a._v("这和通过 SSH 使用 "),t("code",{staticClass:"literal"},[a._v("git-upload-pack")]),a._v(" 是非常相似的，但是第二个数据交换则是一个单独的请求：")]),a._v(" "),t("pre",{staticClass:"source language-"},[t("code",[a._v("=> POST $GIT_URL/git-upload-pack HTTP/1.0\n0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7\n0032have 441b40d833fdfa93eb2908e52742248faf0ee993\n0000")])]),a._v(" "),t("p",[a._v("这个输出格式还是和前面一样的。\n这个请求的响应包含了所需要的包文件，并指明成功或失败。")]),a._v(" "),t("h2",{attrs:{id:"协议总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议总结"}},[a._v("#")]),a._v(" 协议总结")]),a._v(" "),t("p",[a._v("这一章节是传输协议的一个概貌。\n传输协议还有很多其它的特性，像是 "),t("code",{staticClass:"literal"},[a._v("multi_ack")]),a._v(" 或 "),t("code",{staticClass:"literal"},[a._v("side-band")]),a._v("，但是这些内容已经超出了本书的范围。\n我们希望能给你展示客户端和服务端之间的基本交互过程；如果你需要更多的相关知识，你可以参阅 Git 的源代码。")])])}),[],!1,null,null,null);e.default=c.exports}}]);