(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{267:function(t,a,e){t.exports=e.p+"assets/img/data-model-1.e0ca06a2.png"},268:function(t,a,e){t.exports=e.p+"assets/img/data-model-2.b3e55780.png"},269:function(t,a,e){t.exports=e.p+"assets/img/data-model-3.e42601ac.png"},481:function(t,a,e){"use strict";e.r(a);var s=e(28),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"git-对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-对象"}},[t._v("#")]),t._v(" Git 对象")]),t._v(" "),s("p",[t._v("Git 是一个内容寻址文件系统，听起来很酷。但这是什么意思呢？\n这意味着，Git 的核心部分是一个简单的键值对数据库（key-value data store）。\n你可以向 Git 仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。")]),t._v(" "),s("p",[t._v("可以通过底层命令 "),s("code",{staticClass:"literal"},[t._v("git hash-object")]),t._v(" 来演示上述效果——该命令可将任意数据保存于\n"),s("code",{staticClass:"literal"},[t._v(".git/objects")]),t._v(" 目录（即 "),s("strong",[t._v("对象数据库")]),t._v("），并返回指向该数据对象的唯一的键。")]),t._v(" "),s("p",[t._v("首先，我们需要初始化一个新的 Git 版本库，并确认 "),s("code",{staticClass:"literal"},[t._v("objects")]),t._v(" 目录为空：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git init test\nInitialized empty Git repository in /tmp/test/.git/\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" cd test\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" find .git/objects\n.git/objects\n.git/objects/info\n.git/objects/pack\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" find .git/objects -type f")])]),t._v(" "),s("p",[t._v("可以看到 Git 对 "),s("code",{staticClass:"literal"},[t._v("objects")]),t._v(" 目录进行了初始化，并创建了 "),s("code",{staticClass:"literal"},[t._v("pack")]),t._v(" 和 "),s("code",{staticClass:"literal"},[t._v("info")]),t._v(" 子目录，但均为空。\n接着，我们用 "),s("code",{staticClass:"literal"},[t._v("git hash-object")]),t._v(" 创建一个新的数据对象并将它手动存入你的新 Git 数据库中：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" echo "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'test content'")]),t._v(" | git hash-object -w --stdin\nd670460b4b4aece5915caf5c68d12f560a9fe3e4")])]),t._v(" "),s("p",[t._v("在这种最简单的形式中，"),s("code",{staticClass:"literal"},[t._v("git hash-object")]),t._v(" 会接受你传给它的东西，而它只会返回可以存储在 Git 仓库中的唯一键。\n"),s("code",{staticClass:"literal"},[t._v("-w")]),t._v(" 选项会指示该命令不要只返回键，还要将该对象写入数据库中。\n最后，"),s("code",{staticClass:"literal"},[t._v("--stdin")]),t._v(" 选项则指示该命令从标准输入读取内容；若不指定此选项，则须在命令尾部给出待存储文件的路径。")]),t._v(" "),s("p",[t._v("此命令输出一个长度为 40 个字符的校验和。\n这是一个 SHA-1 哈希值——一个将待存储的数据外加一个头部信息（header）一起做 SHA-1 校验运算而得的校验和。后文会简要讨论该头部信息。\n现在我们可以查看 Git 是如何存储数据的：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" find .git/objects -type f\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4")])]),t._v(" "),s("p",[t._v("如果你再次查看 "),s("code",{staticClass:"literal"},[t._v("objects")]),t._v(" 目录，那么可以在其中找到一个与新内容对应的文件。\n这就是开始时 Git 存储内容的方式——一个文件对应一条内容，\n以该内容加上特定头部信息一起的 SHA-1 校验和为文件命名。\n校验和的前两个字符用于命名子目录，余下的 38 个字符则用作文件名。")]),t._v(" "),s("p",[t._v("一旦你将内容存储在了对象数据库中，那么可以通过 "),s("code",{staticClass:"literal"},[t._v("cat-file")]),t._v(" 命令从 Git 那里取回数据。\n这个命令简直就是一把剖析 Git 对象的瑞士军刀。\n为 "),s("code",{staticClass:"literal"},[t._v("cat-file")]),t._v(" 指定 "),s("code",{staticClass:"literal"},[t._v("-p")]),t._v(" 选项可指示该命令自动判断内容的类型，并为我们显示大致的内容：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4\ntest content")])]),t._v(" "),s("p",[t._v("至此，你已经掌握了如何向 Git 中存入内容，以及如何将它们取出。\n我们同样可以将这些操作应用于文件中的内容。\n例如，可以对一个文件进行简单的版本控制。\n首先，创建一个新文件并将其内容存入数据库：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" echo "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'version 1'")]),t._v(" > test.txt\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git hash-object -w test.txt\n83baae61804e65cc73a7201a7252750c76066a30")])]),t._v(" "),s("p",[t._v("接着，向文件里写入新内容，并再次将其存入数据库：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" echo "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'version 2'")]),t._v(" > test.txt\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git hash-object -w test.txt\n1f7a7a472abf3dd9643fd615f6da379c4acb3e3a")])]),t._v(" "),s("p",[t._v("对象数据库记录下了该文件的两个不同版本，当然之前我们存入的第一条内容也还在：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" find .git/objects -type f\n.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4")])]),t._v(" "),s("p",[t._v("现在可以在删掉 "),s("code",{staticClass:"literal"},[t._v("test.txt")]),t._v(" 的本地副本，然后用 Git 从对象数据库中取回它的第一个版本：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" cat test.txt\nversion 1")])]),t._v(" "),s("p",[t._v("或者第二个版本：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" cat test.txt\nversion 2")])]),t._v(" "),s("p",[t._v("然而，记住文件的每一个版本所对应的 SHA-1 值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存——我们仅保存了文件的内容。\n上述类型的对象我们称之为 "),s("strong",[t._v("数据对象（blob object）")]),t._v("。\n利用 "),s("code",{staticClass:"literal"},[t._v("git cat-file -t")]),t._v(" 命令，可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\nblob")])]),t._v(" "),s("h2",{attrs:{id:"树对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#树对象"}},[t._v("#")]),t._v(" 树对象")]),t._v(" "),s("p",[t._v("接下来要探讨的 Git 对象类型是树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。\nGit 以一种类似于 UNIX 文件系统的方式存储内容，但作了些许简化。\n所有内容均以树对象和数据对象的形式存储，其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容。\n一个树对象包含了一条或多条树对象记录（tree entry），每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、类型、文件名信息。\n例如，某项目当前对应的最新树对象可能是这样的：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p master^{tree}\n100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README\n100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile\n040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib")])]),t._v(" "),s("p",[s("code",{staticClass:"literal"},[t._v("master^{tree}")]),t._v(" 语法表示 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支上最新的提交所指向的树对象。\n请注意，"),s("code",{staticClass:"literal"},[t._v("lib")]),t._v(" 子目录（所对应的那条树对象记录）并不是一个数据对象，而是一个指针，其指向的是另一个树对象：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0\n100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb")])]),t._v(" "),s("aside",{staticClass:"admonition note custom-block tip",attrs:{title:"Note","epub:type":"note"}},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("div",{staticClass:"content"},[s("p",[t._v("你可能会在某些 shell 中使用 "),s("code",{staticClass:"literal"},[t._v("master^{tree}")]),t._v(" 语法时遇到错误。")]),t._v(" "),s("p",[t._v("在 Windows 的 CMD 中，字符 "),s("code",{staticClass:"literal"},[t._v("^")]),t._v(" 被用于转义，因此你必须双写它以避免出现问题："),s("code",{staticClass:"literal"},[t._v("git cat-file -p master^^{tree}")]),t._v("。\n在 PowerShell 中使用字符 {} 时则必须用引号引起来，以此来避免参数解析错误："),s("code",{staticClass:"literal"},[t._v("git cat-file -p 'master^{tree}'")]),t._v("。")]),t._v(" "),s("p",[t._v("在 ZSH 中，字符 "),s("code",{staticClass:"literal"},[t._v("^")]),t._v(" 被用在通配模式（globbing）中，因此你必须将整个表达式用引号引起来："),s("code",{staticClass:"literal"},[t._v('git cat-file -p "master^{tree}"')]),t._v("。")])])]),t._v(" "),s("p",[t._v("从概念上讲，Git 内部存储的数据有点像这样：")]),t._v(" "),s("figure",{staticClass:"image"},[s("div",{staticClass:"content"},[s("img",{attrs:{src:e(267),alt:"简化版的 Git 数据模型。"}})]),t._v(" "),s("figcaption",[t._v("Figure 1. 简化版的 Git 数据模型。")])]),t._v(" "),s("p",[t._v("你可以轻松创建自己的树对象。\n通常，Git 根据某一时刻暂存区（即 index 区域，下同）所表示的状态创建并记录一个对应的树对象，\n如此重复便可依次记录（某个时间段内）一系列的树对象。\n因此，为创建一个树对象，首先需要通过暂存一些文件来创建一个暂存区。\n可以通过底层命令 "),s("code",{staticClass:"literal"},[t._v("git update-index")]),t._v(" 为一个单独文件——我们的 test.txt 文件的首个版本——创建一个暂存区。\n利用该命令，可以把 "),s("code",{staticClass:"literal"},[t._v("test.txt")]),t._v(" 文件的首个版本人为地加入一个新的暂存区。\n必须为上述命令指定 "),s("code",{staticClass:"literal"},[t._v("--add")]),t._v(" 选项，因为此前该文件并不在暂存区中（我们甚至都还没来得及创建一个暂存区呢）；\n同样必需的还有 "),s("code",{staticClass:"literal"},[t._v("--cacheinfo")]),t._v(" 选项，因为将要添加的文件位于 Git 数据库中，而不是位于当前目录下。\n同时，需要指定文件模式、SHA-1 与文件名：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git update-index --add --cacheinfo 100644 "),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("\\")]),t._v("\n  83baae61804e65cc73a7201a7252750c76066a30 test.txt")])]),t._v(" "),s("p",[t._v("本例中，我们指定的文件模式为 "),s("code",{staticClass:"literal"},[t._v("100644")]),t._v("，表明这是一个普通文件。\n其他选择包括："),s("code",{staticClass:"literal"},[t._v("100755")]),t._v("，表示一个可执行文件；"),s("code",{staticClass:"literal"},[t._v("120000")]),t._v("，表示一个符号链接。\n这里的文件模式参考了常见的 UNIX 文件模式，但远没那么灵活——上述三种模式即是\nGit 文件（即数据对象）的所有合法模式（当然，还有其他一些模式，但用于目录项和子模块）。")]),t._v(" "),s("p",[t._v("现在，可以通过 "),s("code",{staticClass:"literal"},[t._v("git write-tree")]),t._v(" 命令将暂存区内容写入一个树对象。\n此处无需指定 "),s("code",{staticClass:"literal"},[t._v("-w")]),t._v(" 选项——如果某个树对象此前并不存在的话，当调用此命令时，\n它会根据当前暂存区状态自动创建一个新的树对象：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git write-tree\nd8329fc1cc938780ffdd9f94e0d364e0ea74f579\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt")])]),t._v(" "),s("p",[t._v("不妨用之前见过的 "),s("code",{staticClass:"literal"},[t._v("git cat-file")]),t._v(" 命令验证一下它确实是一个树对象：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579\ntree")])]),t._v(" "),s("p",[t._v("接着我们来创建一个新的树对象，它包括 "),s("code",{staticClass:"literal"},[t._v("test.txt")]),t._v(" 文件的第二个版本，以及一个新的文件：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" echo "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'new file'")]),t._v(" > new.txt\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git update-index --add --cacheinfo 100644 "),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("\\")]),t._v("\n  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git update-index --add new.txt")])]),t._v(" "),s("p",[t._v("暂存区现在包含了 "),s("code",{staticClass:"literal"},[t._v("test.txt")]),t._v(" 文件的新版本，和一个新文件："),s("code",{staticClass:"literal"},[t._v("new.txt")]),t._v("。\n记录下这个目录树（将当前暂存区的状态记录为一个树对象），然后观察它的结构：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git write-tree\n0155eb4229851634a0f03eb265b69f5a2d56f341\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt")])]),t._v(" "),s("p",[t._v("我们注意到，新的树对象包含两条文件记录，同时 test.txt 的 SHA-1 值（"),s("code",{staticClass:"literal"},[t._v("1f7a7a")]),t._v("）是先前值的“第二版”。\n只是为了好玩：你可以将第一个树对象加入第二个树对象，使其成为新的树对象的一个子目录。\n通过调用 "),s("code",{staticClass:"literal"},[t._v("git read-tree")]),t._v(" 命令，可以把树对象读入暂存区。\n本例中，可以通过对该命令指定 "),s("code",{staticClass:"literal"},[t._v("--prefix")]),t._v(" 选项，将一个已有的树对象作为子树读入暂存区：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git write-tree\n3c4e9cd789d88d8d89c1073707c3585e41b0e614\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614\n040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt")])]),t._v(" "),s("p",[t._v("如果基于这个新的树对象创建一个工作目录，你会发现工作目录的根目录包含两个文件以及一个名为\n"),s("code",{staticClass:"literal"},[t._v("bak")]),t._v(" 的子目录，该子目录包含 "),s("code",{staticClass:"literal"},[t._v("test.txt")]),t._v(" 文件的第一个版本。\n可以认为 Git 内部存储着的用于表示上述结构的数据是这样的：")]),t._v(" "),s("figure",{staticClass:"image"},[s("div",{staticClass:"content"},[s("img",{attrs:{src:e(268),alt:"当前 Git 的数据内容结构。"}})]),t._v(" "),s("figcaption",[t._v("Figure 2. 当前 Git 的数据内容结构。")])]),t._v(" "),s("h2",{attrs:{id:"提交对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#提交对象"}},[t._v("#")]),t._v(" 提交对象")]),t._v(" "),s("p",[t._v("如果你做完了以上所有操作，那么现在就有了三个树对象，分别代表我们想要跟踪的不同项目快照。\n然而问题依旧：若想重用这些快照，你必须记住所有三个 SHA-1 哈希值。\n并且，你也完全不知道是谁保存了这些快照，在什么时刻保存的，以及为什么保存这些快照。\n而以上这些，正是提交对象（commit object）能为你保存的基本信息。")]),t._v(" "),s("p",[t._v("可以通过调用 "),s("code",{staticClass:"literal"},[t._v("commit-tree")]),t._v(" 命令创建一个提交对象，为此需要指定一个树对象的 SHA-1 值，以及该提交的父提交对象（如果有的话）。\n我们从之前创建的第一个树对象开始：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" echo "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'first commit'")]),t._v(" | git commit-tree d8329f\nfdf4fc3344e67ab068f836878b6c4951e3b15f3d")])]),t._v(" "),s("p",[t._v("由于创建时间和作者数据不同，你现在会得到一个不同的散列值。\n请将本章后续内容中的提交和标签的散列值替换会你自己的校验和。\n现在可以通过 "),s("code",{staticClass:"literal"},[t._v("git cat-file")]),t._v(" 命令查看这个新提交对象：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p fdf4fc3\ntree d8329fc1cc938780ffdd9f94e0d364e0ea74f579\nauthor Scott Chacon <schacon@gmail.com> 1243040974 -0700\ncommitter Scott Chacon <schacon@gmail.com> 1243040974 -0700\n\nfirst commit")])]),t._v(" "),s("p",[t._v("提交对象的格式很简单：它先指定一个顶层树对象，代表当前项目快照；\n然后是可能存在的父提交（前面描述的提交对象并不存在任何父提交）；\n之后是作者/提交者信息（依据你的 "),s("code",{staticClass:"literal"},[t._v("user.name")]),t._v(" 和 "),s("code",{staticClass:"literal"},[t._v("user.email")]),t._v(" 配置来设定，外加一个时间戳）；\n留空一行，最后是提交注释。")]),t._v(" "),s("p",[t._v("接着，我们将创建另两个提交对象，它们分别引用各自的上一个提交（作为其父提交对象）：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" echo "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'second commit'")]),t._v(" | git commit-tree 0155eb -p fdf4fc3\ncac0cab538b970a37ea1e769cbbde608743bc96d\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" echo "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'third commit'")]),t._v("  | git commit-tree 3c4e9c -p cac0cab\n1a410efbd13591db07496601ebc7a059dd55cfe9")])]),t._v(" "),s("p",[t._v("这三个提交对象分别指向之前创建的三个树对象快照中的一个。\n现在，如果对最后一个提交的 SHA-1 值运行 "),s("code",{staticClass:"literal"},[t._v("git log")]),t._v(" 命令，会出乎意料的发现，你已有一个货真价实的、可由 "),s("code",{staticClass:"literal"},[t._v("git log")]),t._v(" 查看的 Git 提交历史了：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git log --stat 1a410e\ncommit 1a410efbd13591db07496601ebc7a059dd55cfe9\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri May 22 18:15:24 2009 -0700\n\n\tthird commit\n\n bak/test.txt | 1 +\n 1 file changed, 1 insertion(+)\n\ncommit cac0cab538b970a37ea1e769cbbde608743bc96d\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri May 22 18:14:29 2009 -0700\n\n\tsecond commit\n\n new.txt  | 1 +\n test.txt | 2 +-\n 2 files changed, 2 insertions(+), 1 deletion(-)\n\ncommit fdf4fc3344e67ab068f836878b6c4951e3b15f3d\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri May 22 18:09:34 2009 -0700\n\n    first commit\n\n test.txt | 1 +\n 1 file changed, 1 insertion(+)")])]),t._v(" "),s("p",[t._v("太神奇了：\n就在刚才，你没有借助任何上层命令，仅凭几个底层操作便完成了一个 Git 提交历史的创建。\n这就是每次我们运行 "),s("code",{staticClass:"literal"},[t._v("git add")]),t._v(" 和 "),s("code",{staticClass:"literal"},[t._v("git commit")]),t._v(" 命令时，Git 所做的工作实质就是将被改写的文件保存为数据对象，\n更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。\n这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 "),s("code",{staticClass:"literal"},[t._v(".git/objects")]),t._v(" 目录下。\n下面列出了目前示例目录内的所有对象，辅以各自所保存内容的注释：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" find .git/objects -type f\n.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2\n.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3\n.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2\n.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3\n.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1\n.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2\n.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'\n.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1\n.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt\n.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1")])]),t._v(" "),s("p",[t._v("如果跟踪所有的内部指针，将得到一个类似下面的对象关系图：")]),t._v(" "),s("figure",{staticClass:"image"},[s("div",{staticClass:"content"},[s("img",{attrs:{src:e(269),alt:"你的 Git 目录下所有可达的对象。"}})]),t._v(" "),s("figcaption",[t._v("Figure 3. 你的 Git 目录下所有可达的对象。")])]),t._v(" "),s("h2",{attrs:{id:"对象存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象存储"}},[t._v("#")]),t._v(" 对象存储")]),t._v(" "),s("p",[t._v("前文曾提及，你向 Git 仓库提交的所有对象都会有个头部信息一并被保存。\n让我们略花些时间来看看 Git 是如何存储其对象的。\n通过在 Ruby 脚本语言中交互式地演示，你将看到一个数据对象——本例中是字符串“what is up, doc?”——是如何被存储的。")]),t._v(" "),s("p",[t._v("可以通过 "),s("code",{staticClass:"literal"},[t._v("irb")]),t._v(" 命令启动 Ruby 的交互模式：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" irb\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v("> content = "),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"what is up, doc?"')]),t._v('\n=> "what is up, doc?"')])]),t._v(" "),s("p",[t._v("Git 首先会以识别出的对象的类型作为开头来构造一个头部信息，本例中是一个“blob”字符串。\n接着 Git 会在头部的第一部分添加一个空格，随后是数据内容的字节数，最后是一个空字节（null byte）：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v("> header = "),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"blob #{content.length}\\0"')]),t._v('\n=> "blob 16\\u0000"')])]),t._v(" "),s("p",[t._v("Git 会将上述头部信息和原始数据拼接起来，并计算出这条新内容的 SHA-1 校验和。\n在 Ruby 中可以这样计算 SHA-1 值——先通过 "),s("code",{staticClass:"literal"},[t._v("require")]),t._v(" 命令导入 SHA-1 digest 库，\n然后对目标字符串调用 "),s("code",{staticClass:"literal"},[t._v("Digest::SHA1.hexdigest()")]),t._v("：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v('> store = header + content\n=> "blob 16\\u0000what is up, doc?"\n'),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v("> require "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'digest/sha1'")]),t._v("\n=> true\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v('> sha1 = Digest::SHA1.hexdigest(store)\n=> "bd9dbf5aae1a3862dd1526723246b20206e5fc37"')])]),t._v(" "),s("p",[t._v("我们来比较一下 "),s("code",{staticClass:"literal"},[t._v("git hash-object")]),t._v(" 的输出。\n这里使用了 "),s("code",{staticClass:"literal"},[t._v("echo -n")]),t._v(" 以避免在输出中添加换行。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" echo -n "),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"what is up, doc?"')]),t._v(" | git hash-object --stdin\nbd9dbf5aae1a3862dd1526723246b20206e5fc37")])]),t._v(" "),s("p",[t._v("Git 会通过 zlib 压缩这条新内容。在 Ruby 中可以借助 zlib 库做到这一点。\n先导入相应的库，然后对目标内容调用 "),s("code",{staticClass:"literal"},[t._v("Zlib::Deflate.deflate()")]),t._v("：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v("> require "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'zlib'")]),t._v("\n=> true\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v('> zlib_content = Zlib::Deflate.deflate(store)\n=> "x\\x9CK\\xCA\\xC9OR04c(\\xCFH,Q\\xC8,V(-\\xD0QH\\xC9O\\xB6\\a\\x00_\\x1C\\a\\x9D"')])]),t._v(" "),s("p",[t._v("最后，需要将这条经由 zlib 压缩的内容写入磁盘上的某个对象。\n要先确定待写入对象的路径（SHA-1 值的前两个字符作为子目录名称，后 38 个字符则作为子目录内文件的名称）。\n如果该子目录不存在，可以通过 Ruby 中的 "),s("code",{staticClass:"literal"},[t._v("FileUtils.mkdir_p()")]),t._v(" 函数来创建它。\n接着，通过 "),s("code",{staticClass:"literal"},[t._v("File.open()")]),t._v(" 打开这个文件。最后，对上一步中得到的文件句柄调用 "),s("code",{staticClass:"literal"},[t._v("write()")]),t._v(" 函数，以向目标文件写入之前那条 zlib 压缩过的内容：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v("> path = "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'.git/objects/'")]),t._v(" + sha1[0,2] + "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'/'")]),t._v(' + sha1[2,38]\n=> ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"\n'),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v("> require "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'fileutils'")]),t._v("\n=> true\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v('> FileUtils.mkdir_p(File.dirname(path))\n=> ".git/objects/bd"\n'),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v("> File.open(path, "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'w'")]),t._v(") { |f| f.write zlib_content }\n=> 32")])]),t._v(" "),s("p",[t._v("我们用 "),s("code",{staticClass:"literal"},[t._v("git cat-file")]),t._v(" 查看一下该对象的内容：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[t._v("---\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git cat-file -p bd9dbf5aae1a3862dd1526723246b20206e5fc37\nwhat is up, doc?\n---")])]),t._v(" "),s("p",[t._v("就是这样——你已创建了一个有效的 Git 数据对象。")]),t._v(" "),s("p",[t._v("所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。\n另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。")])])}),[],!1,null,null,null);a.default=i.exports}}]);