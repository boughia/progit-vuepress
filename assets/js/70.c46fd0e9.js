(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{480:function(t,s,i){"use strict";i.r(s);var a=i(28),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,i=t._self._c||s;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"底层命令与上层命令"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#底层命令与上层命令"}},[t._v("#")]),t._v(" 底层命令与上层命令")]),t._v(" "),i("p",[t._v("本书主要涵盖了 "),i("code",{staticClass:"literal"},[t._v("checkout")]),t._v("、"),i("code",{staticClass:"literal"},[t._v("branch")]),t._v("、"),i("code",{staticClass:"literal"},[t._v("remote")]),t._v(" 等约 30 个 Git 的子命令。\n然而，由于 Git 最初是一套面向版本控制系统的工具集，而不是一个完整的、用户友好的版本控制系统，\n所以它还包含了一部分用于完成底层工作的子命令。\n这些命令被设计成能以 UNIX 命令行的风格连接在一起，抑或藉由脚本调用，来完成工作。\n这部分命令一般被称作“底层（plumbing）”命令，而那些更友好的命令则被称作“上层（porcelain）”命令。")]),t._v(" "),i("p",[t._v("你或许已经注意到了，本书前九章专注于探讨上层命令。\n然而在本章中，我们将主要面对底层命令。\n因为，底层命令得以让你窥探 Git 内部的工作机制，也有助于说明 Git 是如何完成工作的，以及它为何如此运作。\n多数底层命令并不面向最终用户：它们更适合作为新工具的组件和自定义脚本的组成部分。")]),t._v(" "),i("p",[t._v("当在一个新目录或已有目录执行 "),i("code",{staticClass:"literal"},[t._v("git  init")]),t._v(" 时，Git 会创建一个 "),i("code",{staticClass:"literal"},[t._v(".git")]),t._v(" 目录。\n这个目录包含了几乎所有 Git 存储和操作的东西。\n如若想备份或复制一个版本库，只需把这个目录拷贝至另一处即可。\n本章探讨的所有内容，均位于这个目录内。\n新初始化的 "),i("code",{staticClass:"literal"},[t._v(".git")]),t._v(" 目录的典型结构如下：")]),t._v(" "),i("pre",{staticClass:"language-bash"},[i("code",[i("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" ls -F1\nconfig\ndescription\nHEAD\nhooks/\ninfo/\nobjects/\nrefs/")])]),t._v(" "),i("p",[t._v("随着 Git 版本的不同，该目录下可能还会包含其他内容。\n不过对于一个全新的 "),i("code",{staticClass:"literal"},[t._v("git init")]),t._v(" 版本库，这将是你看到的默认结构。\n"),i("code",{staticClass:"literal"},[t._v("description")]),t._v(" 文件仅供 GitWeb 程序使用，我们无需关心。\n"),i("code",{staticClass:"literal"},[t._v("config")]),t._v(" 文件包含项目特有的配置选项。\n"),i("code",{staticClass:"literal"},[t._v("info")]),t._v(" 目录包含一个全局性排除（global exclude）文件，\n用以放置那些不希望被记录在 "),i("code",{staticClass:"literal"},[t._v(".gitignore")]),t._v(" 文件中的忽略模式（ignored patterns）。\n"),i("code",{staticClass:"literal"},[t._v("hooks")]),t._v(" 目录包含客户端或服务端的钩子脚本（hook scripts），\n在 "),i("a",{staticClass:"xref",attrs:{id:"xref--ch08-customizing-git--_git_hooks",href:"/chapter-8/3.html#git-钩子"}},[t._v("Git 钩子")]),t._v(" 中这部分话题已被详细探讨过。")]),t._v(" "),i("p",[t._v("剩下的四个条目很重要："),i("code",{staticClass:"literal"},[t._v("HEAD")]),t._v(" 文件、（尚待创建的）"),i("code",{staticClass:"literal"},[t._v("index")]),t._v(" 文件，和 "),i("code",{staticClass:"literal"},[t._v("objects")]),t._v(" 目录、"),i("code",{staticClass:"literal"},[t._v("refs")]),t._v(" 目录。\n它们都是 Git 的核心组成部分。\n"),i("code",{staticClass:"literal"},[t._v("objects")]),t._v(" 目录存储所有数据内容；"),i("code",{staticClass:"literal"},[t._v("refs")]),t._v(" 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针；\n"),i("code",{staticClass:"literal"},[t._v("HEAD")]),t._v(" 文件指向目前被检出的分支；"),i("code",{staticClass:"literal"},[t._v("index")]),t._v(" 文件保存暂存区信息。\n我们将详细地逐一检视这四部分，来理解 Git 是如何运转的。")])])}),[],!1,null,null,null);s.default=e.exports}}]);