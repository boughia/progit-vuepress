(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{453:function(t,i,a){"use strict";a.r(i);var s=a(28),e=Object(s.a)({},(function(){var t=this,i=t.$createElement,a=t._self._c||i;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"libgit2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#libgit2"}},[t._v("#")]),t._v(" Libgit2")]),t._v(" "),a("p",[t._v("©\n另外一种可以供你使用的是 Libgit2。\nLibgit2 是一个 Git 的非依赖性的工具，它致力于为其他程序使用 Git 提供更好的 API。\n你可以在 "),a("a",{staticClass:"link",attrs:{href:"https://libgit2.org"}},[t._v("https://libgit2.org")]),t._v(" 找到它。")]),t._v(" "),a("p",[t._v("首先，让我们来看一下 C API 长啥样。\n这是一个旋风式旅行。")]),t._v(" "),a("pre",{staticClass:"source language-c"},[a("code",[a("span",{staticStyle:{"font-style":"italic"}},[t._v("// 打开一个版本库")]),t._v("\ngit_repository *repo;\n"),a("span",{staticStyle:{"font-weight":"bold"}},[t._v("int")]),t._v(" error = git_repository_open(&repo, "),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"/path/to/repository"')]),t._v(");\n\n"),a("span",{staticStyle:{"font-style":"italic"}},[t._v("// 逆向引用 HEAD 到一个提交")]),t._v("\ngit_object *head_commit;\nerror = git_revparse_single(&head_commit, repo, "),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"HEAD^{commit}"')]),t._v(");\ngit_commit *commit = (git_commit*)head_commit;\n\n"),a("span",{staticStyle:{"font-style":"italic"}},[t._v("// 显示这个提交的一些详情")]),t._v("\nprintf("),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"%s"')]),t._v(", git_commit_message(commit));\n"),a("span",{staticStyle:{"font-weight":"bold"}},[t._v("const")]),t._v(" git_signature *author = git_commit_author(commit);\nprintf("),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"%s <%s>')]),a("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("\\n")]),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"')]),t._v(", author->name, author->email);\n"),a("span",{staticStyle:{"font-weight":"bold"}},[t._v("const")]),t._v(" git_oid *tree_id = git_commit_tree_id(commit);\n\n"),a("span",{staticStyle:{"font-style":"italic"}},[t._v("// 清理现场")]),t._v("\ngit_commit_free(commit);\ngit_repository_free(repo);")])]),t._v(" "),a("p",[t._v("前两行打开一个 Git 版本库。\n这个 "),a("code",{staticClass:"literal"},[t._v("git_repository")]),t._v(" 类型代表了一个在内存中带有缓存的指向一个版本库的句柄。\n这是最简单的方法，只是你必须知道一个版本库的工作目录或者一个 "),a("code",{staticClass:"literal"},[t._v(".git")]),t._v(" 文件夹的精确路径。\n另外还有 "),a("code",{staticClass:"literal"},[t._v("git_repository_open_ext")]),t._v(" ，它包括了带选项的搜索， "),a("code",{staticClass:"literal"},[t._v("git_clone")]),t._v(" 及其同类可以用来做远程版本库的本地克隆， "),a("code",{staticClass:"literal"},[t._v("git_repository_init")]),t._v(" 则可以创建一个全新的版本库。")]),t._v(" "),a("p",[t._v("第二段代码使用了一种 rev-parse 语法（要了解更多，请看 "),a("a",{staticClass:"xref",attrs:{id:"xref--ch07-git-tools--_branch_references",href:"/chapter-7/1.html#分支引用"}},[t._v("分支引用")]),t._v(" ）来得到 HEAD 真正指向的提交。\n返回类型是一个 "),a("code",{staticClass:"literal"},[t._v("git_object")]),t._v(" 指针，它指代位于版本库里的 Git 对象数据库中的某个东西。\n"),a("code",{staticClass:"literal"},[t._v("git_object")]),t._v(" 实际上是几种不同的对象的“父”类型，每个“子”类型的内存布局和 "),a("code",{staticClass:"literal"},[t._v("git_object")]),t._v(" 是一样的，所以你能安全地把它们转换为正确的类型。\n在上面的例子中， "),a("code",{staticClass:"literal"},[t._v("git_object_type(commit)")]),t._v(" 会返回 "),a("code",{staticClass:"literal"},[t._v("GIT_OBJ_COMMIT")]),t._v(" ，所以转换成 "),a("code",{staticClass:"literal"},[t._v("git_commit")]),t._v(" 指针是安全的。")]),t._v(" "),a("p",[t._v("下一段展示了如何访问一个提交的详情。\n最后一行使用了 "),a("code",{staticClass:"literal"},[t._v("git_oid")]),t._v(" 类型，这是 Libgit2 用来表示一个 SHA-1 哈希的方法。")]),t._v(" "),a("p",[t._v("从这个例子中，我们可以看到一些模式：")]),t._v(" "),a("div",{staticClass:"itemized-list"},[a("ul",[a("li",[a("span",{staticClass:"principal"},[t._v("如果你声明了一个指针，并在一个 Libgit2 调用中传递一个引用，那么这个调用可能返回一个 int 类型的错误码。\n值 "),a("code",{staticClass:"literal"},[t._v("0")]),t._v(" 表示成功，比它小的则是一个错误。")])]),t._v(" "),a("li",[a("span",{staticClass:"principal"},[t._v("如果 Libgit2 为你填入一个指针，那么你有责任释放它。")])]),t._v(" "),a("li",[a("span",{staticClass:"principal"},[t._v("如果 Libgit2 在一个调用中返回一个 "),a("code",{staticClass:"literal"},[t._v("const")]),t._v(" 指针，你不需要释放它，但是当它所指向的对象被释放时它将不可用。")])]),t._v(" "),a("li",[a("span",{staticClass:"principal"},[t._v("用 C 来写有点蛋疼。")])])])]),t._v(" "),a("p",[t._v("\n最后一点意味着你应该不会在使用 Libgit2 时编写 C 语言程序。\n但幸运的是，有许多可用的各种语言的绑定，能让你在特定的语言和环境中更加容易的操作 Git 版本库。\n我们来看一下下面这个用 Libgit2 的 Ruby 绑定写成的例子，它叫 Rugged，你可以在 "),a("a",{staticClass:"link",attrs:{href:"https://github.com/libgit2/rugged"}},[t._v("https://github.com/libgit2/rugged")]),t._v(" 找到它。")]),t._v(" "),a("pre",{staticClass:"source language-ruby"},[a("code",[t._v("repo = Rugged::Repository.new("),a("span",{staticStyle:{"font-style":"italic"}},[t._v("'path/to/repository'")]),t._v(")\ncommit = repo.head.target\nputs commit.message\nputs "),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"')]),a("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("#{")]),t._v("commit.author["),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":name")]),t._v("]"),a("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("}")]),a("span",{staticStyle:{"font-style":"italic"}},[t._v(" <")]),a("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("#{")]),t._v("commit.author["),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":email")]),t._v("]"),a("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("}")]),a("span",{staticStyle:{"font-style":"italic"}},[t._v('>"')]),t._v("\ntree = commit.tree")])]),t._v(" "),a("p",[t._v("你可以发现，代码看起来更加清晰了。\n首先， Rugged 使用异常机制，它可以抛出类似于 "),a("code",{staticClass:"literal"},[t._v("ConfigError")]),t._v(" 或者 "),a("code",{staticClass:"literal"},[t._v("ObjectError")]),t._v(" 之类的东西来告知错误的情况。\n其次，不需要明确资源释放，因为 Ruby 是支持垃圾回收的。\n我们来看一个稍微复杂一点的例子：从头开始制作一个提交。")]),t._v(" "),a("pre",{staticClass:"source language-ruby"},[a("code",[t._v("blob_id = repo.write("),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"Blob contents"')]),t._v(", "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":blob")]),t._v(") "),a("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v("\n\nindex = repo.index\nindex.read_tree(repo.head.target.tree)\nindex.add("),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":path")]),t._v(" => "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("'newfile.txt'")]),t._v(", "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":oid")]),t._v(" => blob_id) "),a("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v("\n\nsig = {\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":email")]),t._v(" => "),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"bob@example.com"')]),t._v(",\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":name")]),t._v(" => "),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"Bob User"')]),t._v(",\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":time")]),t._v(" => Time.now,\n}\n\ncommit_id = Rugged::Commit.create(repo,\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":tree")]),t._v(" => index.write_tree(repo), "),a("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v("\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":author")]),t._v(" => sig,\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":committer")]),t._v(" => sig, "),a("i",{staticClass:"conum",attrs:{"data-value":"4"}},[t._v("④")]),t._v("\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":message")]),t._v(" => "),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"Add newfile.txt"')]),t._v(", "),a("i",{staticClass:"conum",attrs:{"data-value":"5"}},[t._v("⑤")]),t._v("\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":parents")]),t._v(" => repo.empty? ? [] : [ repo.head.target ].compact, "),a("i",{staticClass:"conum",attrs:{"data-value":"6"}},[t._v("⑥")]),t._v("\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v(":update_ref")]),t._v(" => "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("'HEAD'")]),t._v(", "),a("i",{staticClass:"conum",attrs:{"data-value":"7"}},[t._v("⑦")]),t._v("\n)\ncommit = repo.lookup(commit_id) "),a("i",{staticClass:"conum",attrs:{"data-value":"8"}},[t._v("⑧")])])]),t._v(" "),a("div",{staticClass:"callout-list"},[a("ol",[a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v(" 创建一个新的 blob ，它包含了一个新文件的内容。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v(" 将 HEAD 提交树填入索引，并在路径 "),a("code",{staticClass:"literal"},[t._v("newfile.txt")]),t._v(" 增加新文件。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v(" 这就在 ODB 中创建了一个新的树，并在一个新的提交中使用它。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"4"}},[t._v("④")]),t._v(" 我们在 author 栏和 committer 栏使用相同的签名。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"5"}},[t._v("⑤")]),t._v(" 提交的信息。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"6"}},[t._v("⑥")]),t._v(" 当创建一个提交时，你必须指定这个新提交的父提交。\n这里使用了 HEAD 的末尾作为单一的父提交。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"7"}},[t._v("⑦")]),t._v(" 在做一个提交的过程中， Rugged （和 Libgit2 ）能在需要时更新引用。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"8"}},[t._v("⑧")]),t._v(" 返回值是一个新提交对象的 SHA-1 哈希，你可以用它来获得一个 "),a("code",{staticClass:"literal"},[t._v("Commit")]),t._v(" 对象。")])])]),t._v(" "),a("p",[t._v("Ruby 的代码很好很简洁，另一方面因为 Libgit2 做了大量工作，所以代码运行起来其实速度也不赖。\n如果你不是一个 Ruby 程序员，我们在 "),a("a",{staticClass:"xref",attrs:{id:"xref-_libgit2_bindings",href:"#_libgit2_bindings"}},[t._v("其它绑定")]),t._v(" 有提到其它的一些绑定。")]),t._v(" "),a("h2",{attrs:{id:"高级功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高级功能"}},[t._v("#")]),t._v(" 高级功能")]),t._v(" "),a("p",[t._v("Libgit2 有几个超过核心 Git 的能力。\n例如它的可定制性：Libgit2 允许你为一些不同类型的操作自定义的“后端”，让你得以使用与原生 Git 不同的方式存储东西。\nLibgit2 允许为自定义后端指定配置、引用的存储以及对象数据库，")]),t._v(" "),a("p",[t._v("我们来看一下它究竟是怎么工作的。\n下面的例子借用自 Libgit2 团队提供的后端样本集 （可以在 "),a("a",{staticClass:"link",attrs:{href:"https://github.com/libgit2/libgit2-backends"}},[t._v("https://github.com/libgit2/libgit2-backends")]),t._v(" 上找到）。\n一个对象数据库的自定义后端是这样建立的：")]),t._v(" "),a("pre",{staticClass:"source language-c"},[a("code",[t._v("git_odb *odb;\n"),a("span",{staticStyle:{"font-weight":"bold"}},[t._v("int")]),t._v(" error = git_odb_new(&odb); "),a("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v("\n\ngit_odb_backend *my_backend;\nerror = git_odb_backend_mine(&my_backend, "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("/*…*/")]),t._v("); "),a("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v("\n\nerror = git_odb_add_backend(odb, my_backend, 1); "),a("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v("\n\ngit_repository *repo;\nerror = git_repository_open(&repo, "),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"some-path"')]),t._v(");\nerror = git_repository_set_odb(repo, odb); "),a("i",{staticClass:"conum",attrs:{"data-value":"4"}},[t._v("④")])])]),t._v(" "),a("p",[a("em",[t._v("（注意：这个错误被捕获了，但是没有被处理。我们希望你的代码比我们的更好。）")])]),t._v(" "),a("div",{staticClass:"callout-list"},[a("ol",[a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v(" 初始化一个空的对象数据库（ ODB ）“前端”，它将被作为一个用来做真正的工作的“后端”的容器。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v(" 初始化一个自定义 ODB 后端。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v(" 为这个前端增加一个后端。")]),t._v(" "),a("li",[a("i",{staticClass:"conum",attrs:{"data-value":"4"}},[t._v("④")]),t._v(" 打开一个版本库，并让它使用我们的 ODB 来寻找对象。")])])]),t._v(" "),a("p",[t._v("但是 "),a("code",{staticClass:"literal"},[t._v("git_odb_backend_mine")]),t._v(" 是个什么东西呢？\n嗯，那是一个你自己的 ODB 实现的构造器，并且你能在那里做任何你想做的事，前提是你能正确地填写 "),a("code",{staticClass:"literal"},[t._v("git_odb_backend")]),t._v(" 结构。\n它看起来_应该_是这样的：")]),t._v(" "),a("pre",{staticClass:"source language-c"},[a("code",[a("span",{staticStyle:{"font-weight":"bold"}},[t._v("typedef")]),t._v(" "),a("span",{staticStyle:{"font-weight":"bold"}},[t._v("struct")]),t._v(" {\n    git_odb_backend parent;\n\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("// 其它的一些东西")]),t._v("\n    "),a("span",{staticStyle:{"font-weight":"bold"}},[t._v("void")]),t._v(" *custom_context;\n} my_backend_struct;\n\n"),a("span",{staticStyle:{"font-weight":"bold"}},[t._v("int")]),t._v(" git_odb_backend_mine(git_odb_backend **backend_out, "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("/*…*/")]),t._v(")\n{\n    my_backend_struct *backend;\n\n    backend = calloc(1, "),a("span",{staticStyle:{"font-weight":"bold"}},[t._v("sizeof")]),t._v(" (my_backend_struct));\n\n    backend->custom_context = "),a("span",{staticStyle:{border:"1px solid #FF0000"}},[t._v("…")]),t._v(";\n\n    backend->parent.read = &my_backend__read;\n    backend->parent.read_prefix = &my_backend__read_prefix;\n    backend->parent.read_header = &my_backend__read_header;\n    "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("// ……")]),t._v("\n\n    *backend_out = (git_odb_backend *) backend;\n\n    "),a("span",{staticStyle:{"font-weight":"bold"}},[t._v("return")]),t._v(" GIT_SUCCESS;\n}")])]),t._v(" "),a("p",[a("code",{staticClass:"literal"},[t._v("my_backend_struct")]),t._v(" 的第一个成员必须是一个 "),a("code",{staticClass:"literal"},[t._v("git_odb_backend")]),t._v(" 结构，这是一个微妙的限制：这样就能确保内存布局是 Libgit2 的代码所期望的样子。\n其余都是随意的，这个结构的大小可以随心所欲。")]),t._v(" "),a("p",[t._v("这个初始化函数为该结构分配内存，设置自定义的上下文，然后填写它支持的 "),a("code",{staticClass:"literal"},[t._v("parent")]),t._v(" 结构的成员。\n阅读 Libgit2 的 "),a("code",{staticClass:"literal"},[t._v("include/git2/sys/odb_backend.h")]),t._v(" 源码以了解全部调用签名，你特定的使用环境会帮你决定使用哪一种调用签名。")]),t._v(" "),a("h2",{attrs:{id:"其它绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其它绑定"}},[t._v("#")]),t._v(" 其它绑定")]),t._v(" "),a("p",[t._v("Libgit2 有很多种语言的绑定。\n在这篇文章中，我们展现了一个使用了几个更加完整的绑定包的小例子，这些库存在于许多种语言中，包括 C++、Go、Node.js、Erlang 以及 JVM ，它们的成熟度各不相同。\n官方的绑定集合可以通过浏览这个版本库得到：https://github.com/libgit2[] 。\n我们写的代码将返回当前 HEAD 指向的提交的提交信息（就像 "),a("code",{staticClass:"literal"},[t._v("git log -1")]),t._v(" 那样）。")]),t._v(" "),a("h3",{attrs:{id:"libgit2sharp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#libgit2sharp"}},[t._v("#")]),t._v(" LibGit2Sharp")]),t._v(" "),a("p",[t._v("\n如果你在编写一个 .NET 或者 Mono 应用，那么 LibGit2Sharp ("),a("a",{staticClass:"link",attrs:{href:"https://github.com/libgit2/libgit2sharp"}},[t._v("https://github.com/libgit2/libgit2sharp")]),t._v(") 就是你所需要的。\n这个绑定是用 C# 写成的，并且已经采取许多措施来用令人感到自然的 CLR API 包装原始的 Libgit2 的调用。\n我们的例子看起来就像这样：")]),t._v(" "),a("pre",{staticClass:"source language-csharp"},[a("code",[a("span",{staticStyle:{"font-weight":"bold"}},[t._v("new")]),t._v(" Repository("),a("span",{staticStyle:{"font-style":"italic"}},[t._v('@"C:\\path\\to\\repo"')]),t._v(").Head.Tip.Message;")])]),t._v(" "),a("p",[t._v("对于 Windows 桌面应用，一个叫做 NuGet 的包会让你快速上手。")]),t._v(" "),a("h3",{attrs:{id:"objective-git"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#objective-git"}},[t._v("#")]),t._v(" objective-git")]),t._v(" "),a("p",[t._v("\n如果你的应用运行在一个 Apple 平台上，你很有可能使用 Objective-C 作为实现语言。\nObjective-Git ("),a("a",{staticClass:"link",attrs:{href:"https://github.com/libgit2/objective-git"}},[t._v("https://github.com/libgit2/objective-git")]),t._v(") 是这个环境下的 Libgit2 绑定。\n一个例子看起来类似这样：")]),t._v(" "),a("pre",{staticClass:"source language-objc"},[a("code",[t._v("GTRepository *repo =\n    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: "),a("span",{staticStyle:{"font-style":"italic"}},[t._v('@"/path/to/repo"')]),t._v("] error:NULL];\nNSString *msg = [[[epo headReferenceWithError:NULL] resolvedTarget] message];")])]),t._v(" "),a("p",[t._v("Objective-git 与 Swift 完美兼容，所以你把 Objective-C 落在一边的时候不用恐惧。")]),t._v(" "),a("h3",{attrs:{id:"pygit2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pygit2"}},[t._v("#")]),t._v(" pygit2")]),t._v(" "),a("p",[t._v("\nPython 的 Libgit2 绑定叫做 Pygit2 ，你可以在 "),a("a",{staticClass:"link",attrs:{href:"https://www.pygit2.org/"}},[t._v("https://www.pygit2.org/")]),t._v(" 找到它。\n我们的示例程序：")]),t._v(" "),a("pre",{staticClass:"source language-python"},[a("code",[t._v("pygit2.Repository("),a("span",{staticStyle:{"font-style":"italic"}},[t._v('"/path/to/repo"')]),t._v(") "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("# 打开代码仓库")]),t._v("\n    .head                          "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("# 获取当前分支")]),t._v("\n    .peel(pygit2.Commit)           "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("# 找到对应的提交")]),t._v("\n    .message                       "),a("span",{staticStyle:{"font-style":"italic"}},[t._v("# 读取提交信息")])])]),t._v(" "),a("h2",{attrs:{id:"扩展阅读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展阅读"}},[t._v("#")]),t._v(" 扩展阅读")]),t._v(" "),a("p",[t._v("当然，完全阐述 Libgit2 的能力已超出本书范围。\n如果你想了解更多关于 Libgit2 的信息，可以浏览它的 API 文档： "),a("a",{staticClass:"link",attrs:{href:"https://libgit2.github.com/libgit2"}},[t._v("https://libgit2.github.com/libgit2")]),t._v(", 以及一系列的指南： "),a("a",{staticClass:"link",attrs:{href:"https://libgit2.github.com/docs"}},[t._v("https://libgit2.github.com/docs")]),t._v(".\n对于其它的绑定，检查附带的 README 和测试文件，那里通常有简易教程，以及指向拓展阅读的链接。")])])}),[],!1,null,null,null);i.default=e.exports}}]);