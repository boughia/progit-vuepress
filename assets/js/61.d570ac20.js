(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{468:function(t,e,r){"use strict";r.r(e);var a=r(28),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"补丁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#补丁"}},[t._v("#")]),t._v(" 补丁")]),t._v(" "),r("p",[t._v("Git 中的一些命令是以引入的变更即提交这样的概念为中心的，这样一系列的提交，就是一系列的补丁。\n这些命令以这样的方式来管理你的分支。")]),t._v(" "),r("h2",{attrs:{id:"git-cherry-pick"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-cherry-pick"}},[t._v("#")]),t._v(" git cherry-pick")]),t._v(" "),r("p",[r("code",{staticClass:"literal"},[t._v("git cherry-pick")]),t._v(" 命令用来获得在单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上。\n从一个分支单独一个或者两个提交而不是合并整个分支的所有变更是非常有用的。")]),t._v(" "),r("p",[t._v("在 "),r("a",{staticClass:"xref",attrs:{id:"xref--ch05-distributed-git--_rebase_cherry_pick",href:"/chapter-5/3.html#变基与拣选工作流"}},[t._v("变基与拣选工作流")]),t._v(" 一节中描述和演示了 "),r("code",{staticClass:"literal"},[t._v("Cherry picking")])]),t._v(" "),r("h2",{attrs:{id:"git-rebase"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-rebase"}},[t._v("#")]),t._v(" git rebase")]),t._v(" "),r("p",[r("code",{staticClass:"literal"},[t._v("git rebase")]),t._v(" 命令基本是是一个自动化的 "),r("code",{staticClass:"literal"},[t._v("cherry-pick")]),t._v(" 命令。\n它计算出一系列的提交，然后再以它们在其他地方以同样的顺序一个一个的 "),r("code",{staticClass:"literal"},[t._v("cherry-picks")]),t._v(" 出它们。")]),t._v(" "),r("p",[t._v("在 "),r("a",{staticClass:"xref",attrs:{href:"/chapter-3/6.html#变基"}},[t._v("变基")]),t._v(" 一章中详细提到了此命令，包括与已经公开的分支的变基所涉及的协作问题。")]),t._v(" "),r("p",[t._v("在 "),r("a",{staticClass:"xref",attrs:{id:"xref--ch07-git-tools--_replace",href:"/chapter-7/13.html#替换"}},[t._v("替换")]),t._v(" 中我们在一个分离历史记录到两个单独的仓库的示例中实践了此命令，同时使用了 "),r("code",{staticClass:"literal"},[t._v("--onto")]),t._v(" 选项。")]),t._v(" "),r("p",[t._v("在 "),r("a",{staticClass:"xref",attrs:{id:"xref--ch07-git-tools--ef_rerere",href:"/chapter-7/9.html#rerere"}},[t._v("Rerere")]),t._v(" 一节中，我们研究了在变基时遇到的合并冲突的问题。")]),t._v(" "),r("p",[t._v("在 "),r("a",{staticClass:"xref",attrs:{id:"xref--ch07-git-tools--_changing_multiple",href:"/chapter-7/6.html#修改多个提交信息"}},[t._v("修改多个提交信息")]),t._v(" 一节中，我们也结合 "),r("code",{staticClass:"literal"},[t._v("-i")]),t._v(" 选项将其用于交互式的脚本模式。")]),t._v(" "),r("h2",{attrs:{id:"git-revert"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-revert"}},[t._v("#")]),t._v(" git revert")]),t._v(" "),r("p",[r("code",{staticClass:"literal"},[t._v("git revert")]),t._v(" 命令本质上就是一个逆向的 "),r("code",{staticClass:"literal"},[t._v("git cherry-pick")]),t._v(" 操作。\n它将你提交中的变更的以完全相反的方式的应用到一个新创建的提交中，本质上就是撤销或者倒转。")]),t._v(" "),r("p",[t._v("我们在 "),r("a",{staticClass:"xref",attrs:{id:"xref--ch07-git-tools--_reverse_commit",href:"/chapter-7/8.html#还原提交"}},[t._v("还原提交")]),t._v(" 一节中使用此命令来撤销一个合并提交。")])])}),[],!1,null,null,null);e.default=s.exports}}]);