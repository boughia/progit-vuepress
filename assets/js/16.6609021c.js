(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{424:function(t,e,a){t.exports=a.p+"assets/img/undomerge-start.4c9bf03b.png"},425:function(t,e,a){t.exports=a.p+"assets/img/undomerge-reset.a06917ed.png"},426:function(t,e,a){t.exports=a.p+"assets/img/undomerge-revert.2fc1598e.png"},427:function(t,e,a){t.exports=a.p+"assets/img/undomerge-revert2.ca44cdcc.png"},428:function(t,e,a){t.exports=a.p+"assets/img/undomerge-revert3.39555589.png"},543:function(t,e,a){"use strict";a.r(e);var s=a(28),l=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"高级合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高级合并"}},[t._v("#")]),t._v(" 高级合并")]),t._v(" "),s("p",[t._v("在 Git 中合并是相当容易的。\n因为 Git 使多次合并另一个分支变得很容易，这意味着你可以有一个始终保持最新的长期分支，\n经常解决小的冲突，比在一系列提交后解决一个巨大的冲突要好。")]),t._v(" "),s("p",[t._v("然而，有时也会有棘手的冲突。\n不像其他的版本控制系统，Git 并不会尝试过于聪明的合并冲突解决方案。\nGit 的哲学是聪明地决定无歧义的合并方案，但是如果有冲突，它不会尝试智能地自动解决它。\n因此，如果很久之后才合并两个分叉的分支，你可能会撞上一些问题。")]),t._v(" "),s("p",[t._v("在本节中，我们将会仔细查看那些问题是什么以及 Git 给了我们什么工具来帮助我们处理这些更难办的情形。\n我们也会了解你可以做的不同的、非标准类型的合并，也会看到如何后退到合并之前。")]),t._v(" "),s("h2",{attrs:{id:"合并冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并冲突"}},[t._v("#")]),t._v(" 合并冲突")]),t._v(" "),s("p",[t._v("我们在 "),s("a",{staticClass:"xref",attrs:{id:"xref--ch03-git-branching--_basic_merge_conflicts",href:"/chapter-3/2.html#遇到冲突时的分支合并"}},[t._v("遇到冲突时的分支合并")]),t._v(" 介绍了解决合并冲突的一些基础知识，\n对于更复杂的冲突，Git 提供了几个工具来帮助你指出将会发生什么以及如何更好地处理冲突。")]),t._v(" "),s("p",[t._v("首先，在做一次可能有冲突的合并前尽可能保证工作目录是干净的。\n如果你有正在做的工作，要么提交到一个临时分支要么储藏它。\n这使你可以撤消在这里尝试做的 "),s("strong",[t._v("任何事情")]),t._v(" 。\n如果在你尝试一次合并时工作目录中有未保存的改动，下面的这些技巧可能会使你丢失那些工作。")]),t._v(" "),s("p",[t._v("让我们通过一个非常简单的例子来了解一下。\n我们有一个超级简单的打印 "),s("em",[t._v("hello world")]),t._v(" 的 Ruby 文件。")]),t._v(" "),s("pre",{staticClass:"source language-ruby"},[s("code",[s("span",{staticStyle:{"font-style":"italic"}},[t._v("#! /usr/bin/env ruby")]),t._v("\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("def")]),t._v(" hello\n  puts "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'hello world'")]),t._v("\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("end")]),t._v("\n\nhello()")])]),t._v(" "),s("p",[t._v("在我们的仓库中，创建一个名为 "),s("code",{staticClass:"literal"},[t._v("whitespace")]),t._v(" 的新分支并将所有 Unix 换行符修改为 DOS 换行符，\n实质上虽然改变了文件的每一行，但改变的都只是空白字符。\n然后我们修改行 “hello world” 为 “hello mundo”。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git checkout -b whitespace\nSwitched to a new branch 'whitespace'\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" unix2dos hello.rb\nunix2dos: converting file hello.rb to DOS format ...\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git commit -am "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'converted hello.rb to DOS'")]),t._v("\n[whitespace 3270f76] converted hello.rb to DOS\n 1 file changed, 7 insertions(+), 7 deletions(-)\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" vim hello.rb\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff -b\ndiff --git a/hello.rb b/hello.rb\nindex ac51efd..e85207e 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -1,7 +1,7 @@\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(" #")]),t._v("! /usr/bin/env ruby\n\n def hello\n-  puts 'hello world'\n+  puts 'hello mundo'^M\n end\n\n hello()\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git commit -am "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'hello mundo change'")]),t._v("\n[whitespace 6d338d2] hello mundo change\n 1 file changed, 1 insertion(+), 1 deletion(-)")])]),t._v(" "),s("p",[t._v("现在我们切换回我们的 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支并为函数增加一些注释。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git checkout master\nSwitched to branch 'master'\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" vim hello.rb\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff\ndiff --git a/hello.rb b/hello.rb\nindex ac51efd..36c06c8 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -1,5 +1,6 @@\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(" #")]),t._v("! /usr/bin/env ruby\n\n+# prints out a greeting\n def hello\n   puts 'hello world'\n end\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git commit -am "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'document the function'")]),t._v("\n[master bec6336] document the function\n 1 file changed, 1 insertion(+)")])]),t._v(" "),s("p",[t._v("现在我们尝试合并入我们的 "),s("code",{staticClass:"literal"},[t._v("whitespace")]),t._v(" 分支，因为修改了空白字符，所以合并会出现冲突。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge whitespace\nAuto-merging hello.rb\nCONFLICT (content): Merge conflict in hello.rb\nAutomatic merge failed; fix conflicts and then commit the result.")])]),t._v(" "),s("h3",{attrs:{id:"中断一次合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中断一次合并"}},[t._v("#")]),t._v(" 中断一次合并")]),t._v(" "),s("p",[t._v("我们现在有几个选项。\n首先，让我们介绍如何摆脱这个情况。\n你可能不想处理冲突这种情况，完全可以通过 "),s("code",{staticClass:"literal"},[t._v("git merge --abort")]),t._v(" 来简单地退出合并。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git status -sb\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("#")]),s("span",{staticStyle:{"font-style":"italic"}},[t._v("# master")]),t._v("\nUU hello.rb\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge --abort\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git status -sb\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("#")]),s("span",{staticStyle:{"font-style":"italic"}},[t._v("# master")])])]),t._v(" "),s("p",[s("code",{staticClass:"literal"},[t._v("git merge --abort")]),t._v(" 选项会尝试恢复到你运行合并前的状态。\n但当运行命令前，在工作目录中有未储藏、未提交的修改时它不能完美处理，除此之外它都工作地很好。")]),t._v(" "),s("p",[t._v("如果出于某些原因你想要重来一次，也可以运行 "),s("code",{staticClass:"literal"},[t._v("git reset --hard HEAD")]),t._v(" 回到上一次提交的状态。\n请牢记此时任何未提交的工作都会丢失，所以请确认你不需要保留任何改动。")]),t._v(" "),s("h3",{attrs:{id:"忽略空白"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#忽略空白"}},[t._v("#")]),t._v(" 忽略空白")]),t._v(" "),s("p",[t._v("在这个特定的例子中，冲突与空白有关。\n我们知道这点是因为这个例子很简单，但是在实际的例子中发现这样的冲突也很容易，\n因为每一行都被移除而在另一边每一行又被加回来了。\n默认情况下，Git 认为所有这些行都改动了，所以它不会合并文件。")]),t._v(" "),s("p",[t._v("默认合并策略可以带有参数，其中的几个正好是关于忽略空白改动的。\n如果你看到在一次合并中有大量关于空白的问题，你可以直接中止它并重做一次，\n这次使用 "),s("code",{staticClass:"literal"},[t._v("-Xignore-all-space")]),t._v(" 或 "),s("code",{staticClass:"literal"},[t._v("-Xignore-space-change")]),t._v(" 选项。\n第一个选项在比较行时 "),s("strong",[t._v("完全忽略")]),t._v(" 空白修改，第二个选项将一个空白符与多个连续的空白字符视作等价的。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge -Xignore-space-change whitespace\nAuto-merging hello.rb\nMerge made by the 'recursive' strategy.\n hello.rb | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)")])]),t._v(" "),s("p",[t._v("因为在本例中，实际上文件修改并没有冲突，一旦我们忽略空白修改，每一行都能被很好地合并。")]),t._v(" "),s("p",[t._v("如果你的团队中的某个人可能不小心重新格式化空格为制表符或者相反的操作，这会是一个救命稻草。")]),t._v(" "),s("h3",{attrs:{id:"手动文件再合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#手动文件再合并"}},[t._v("#")]),t._v(" 手动文件再合并")]),t._v(" "),s("p",[t._v("虽然 Git 对空白的预处理做得很好，还有很多其他类型的修改，Git 也许无法自动处理，但是脚本可以处理它们。\n例如，假设 Git 无法处理空白修改因此我们需要手动处理。")]),t._v(" "),s("p",[t._v("我们真正想要做的是对将要合并入的文件在真正合并前运行 "),s("code",{staticClass:"literal"},[t._v("dos2unix")]),t._v(" 程序。\n所以如果那样的话，我们该如何做？")]),t._v(" "),s("p",[t._v("首先，我们进入到了合并冲突状态。\n然后我们想要我的版本的文件，他们的版本的文件（从我们将要合并入的分支）和共同的版本的文件（从分支叉开时的位置）的拷贝。\n然后我们想要修复任何一边的文件，并且为这个单独的文件重试一次合并。")]),t._v(" "),s("p",[t._v("获得这三个文件版本实际上相当容易。\nGit 在索引中存储了所有这些版本，在 “stages” 下每一个都有一个数字与它们关联。\nStage 1 是它们共同的祖先版本，stage 2 是你的版本，stage 3 来自于 "),s("code",{staticClass:"literal"},[t._v("MERGE_HEAD")]),t._v("，即你将要合并入的版本（“theirs”）。")]),t._v(" "),s("p",[t._v("通过 "),s("code",{staticClass:"literal"},[t._v("git show")]),t._v(" 命令与一个特别的语法，你可以将冲突文件的这些版本释放出一份拷贝。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git show :1:hello.rb > hello.common.rb\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git show :2:hello.rb > hello.ours.rb\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git show :3:hello.rb > hello.theirs.rb")])]),t._v(" "),s("p",[t._v("如果你想要更专业一点，也可以使用 "),s("code",{staticClass:"literal"},[t._v("ls-files -u")]),t._v(" 底层命令来得到这些文件的 Git blob 对象的实际 SHA-1 值。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git ls-files -u\n100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1\thello.rb\n100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2\thello.rb\n100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3\thello.rb")])]),t._v(" "),s("p",[s("code",{staticClass:"literal"},[t._v(":1:hello.rb")]),t._v(" 只是查找那个 blob 对象 SHA-1 值的简写。")]),t._v(" "),s("p",[t._v("既然在我们的工作目录中已经有这所有三个阶段的内容，我们可以手工修复它们来修复空白问题，然后使用鲜为人知的 "),s("code",{staticClass:"literal"},[t._v("git merge-file")]),t._v(" 命令来重新合并那个文件。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" dos2unix hello.theirs.rb\ndos2unix: converting file hello.theirs.rb to Unix format ...\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge-file -p "),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("\\")]),t._v("\n    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff -b\ndiff --cc hello.rb\nindex 36c06c8,e85207e..0000000\n--- a/hello.rb\n+++ b/hello.rb\n@@@ -1,8 -1,7 +1,8 @@@\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("  #")]),t._v("! /usr/bin/env ruby\n\n +# prints out a greeting\n  def hello\n-   puts 'hello world'\n+   puts 'hello mundo'\n  end\n\n  hello()")])]),t._v(" "),s("p",[t._v("在这时我们已经漂亮地合并了那个文件。\n实际上，这比使用 "),s("code",{staticClass:"literal"},[t._v("ignore-space-change")]),t._v(" 选项要更好，因为在合并前真正地修复了空白修改而不是简单地忽略它们。\n在使用 "),s("code",{staticClass:"literal"},[t._v("ignore-space-change")]),t._v(" 进行合并操作后，我们最终得到了有几行是 DOS 行尾的文件，从而使提交内容混乱了。")]),t._v(" "),s("p",[t._v("如果你想要在最终提交前看一下我们这边与另一边之间实际的修改，\n你可以使用 "),s("code",{staticClass:"literal"},[t._v("git diff")]),t._v(" 来比较将要提交作为合并结果的工作目录与其中任意一个阶段的文件差异。\n让我们看看它们。")]),t._v(" "),s("p",[t._v("要在合并前比较结果与在你的分支上的内容，换一句话说，看看合并引入了什么，可以运行 "),s("code",{staticClass:"literal"},[t._v("git diff --ours")])]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff --ours\n* Unmerged path hello.rb\ndiff --git a/hello.rb b/hello.rb\nindex 36c06c8..44d0a25 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -2,7 +2,7 @@\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(" #")]),t._v(" prints out a greeting\n def hello\n-  puts 'hello world'\n+  puts 'hello mundo'\n end\n\n hello()")])]),t._v(" "),s("p",[t._v("这里我们可以很容易地看到在我们的分支上发生了什么，在这次合并中我们实际引入到这个文件的改动，是修改了其中一行。")]),t._v(" "),s("p",[t._v("如果我们想要查看合并的结果与他们那边有什么不同，可以运行 "),s("code",{staticClass:"literal"},[t._v("git diff --theirs")]),t._v("。\n在本例及后续的例子中，我们会使用 "),s("code",{staticClass:"literal"},[t._v("-b")]),t._v(" 来去除空白，因为我们将它与 Git 中的，\n而不是我们清理过的 "),s("code",{staticClass:"literal"},[t._v("hello.theirs.rb")]),t._v(" 文件比较。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff --theirs -b\n* Unmerged path hello.rb\ndiff --git a/hello.rb b/hello.rb\nindex e85207e..44d0a25 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -1,5 +1,6 @@\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(" #")]),t._v("! /usr/bin/env ruby\n\n+# prints out a greeting\n def hello\n   puts 'hello mundo'\n end")])]),t._v(" "),s("p",[t._v("最终，你可以通过 "),s("code",{staticClass:"literal"},[t._v("git diff --base")]),t._v(" 来查看文件在两边是如何改动的。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff --base -b\n* Unmerged path hello.rb\ndiff --git a/hello.rb b/hello.rb\nindex ac51efd..44d0a25 100755\n--- a/hello.rb\n+++ b/hello.rb\n@@ -1,7 +1,8 @@\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(" #")]),t._v("! /usr/bin/env ruby\n\n+# prints out a greeting\n def hello\n-  puts 'hello world'\n+  puts 'hello mundo'\n end\n\n hello()")])]),t._v(" "),s("p",[t._v("在这时我们可以使用 "),s("code",{staticClass:"literal"},[t._v("git clean")]),t._v(" 命令来清理我们为手动合并而创建但不再有用的额外文件。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git clean -f\nRemoving hello.common.rb\nRemoving hello.ours.rb\nRemoving hello.theirs.rb")])]),t._v(" "),s("h3",{attrs:{id:"检出冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#检出冲突"}},[t._v("#")]),t._v(" 检出冲突")]),t._v(" "),s("p",[t._v("也许有时我们并不满意这样的解决方案，或许有时还要手动编辑一边或者两边的冲突，但还是依旧无法正常工作，这时我们需要更多的上下文关联来解决这些冲突。")]),t._v(" "),s("p",[t._v("让我们来稍微改动下例子。\n对于本例，我们有两个长期分支，每一个分支都有几个提交，但是在合并时却创建了一个合理的冲突。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git log --graph --oneline --decorate --all\n* f1270f7 (HEAD, master) update README\n* 9af9d3b add a README\n* 694971d update phrase to hola world\n| * e3eb223 (mundo) add more tests\n| * 7cff591 add testing script\n| * c3ffff1 changed text to hello mundo\n|/\n* b7dcc89 initial hello world code")])]),t._v(" "),s("p",[t._v("现在有只在 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支上的三次单独提交，还有其他三次提交在 "),s("code",{staticClass:"literal"},[t._v("mundo")]),t._v(" 分支上。\n如果我们尝试将 "),s("code",{staticClass:"literal"},[t._v("mundo")]),t._v(" 分支合并入 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支，我们得到一个冲突。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge mundo\nAuto-merging hello.rb\nCONFLICT (content): Merge conflict in hello.rb\nAutomatic merge failed; fix conflicts and then commit the result.")])]),t._v(" "),s("p",[t._v("我们想要看一下合并冲突是什么。\n如果我们打开这个文件，我们将会看到类似下面的内容：")]),t._v(" "),s("pre",{staticClass:"source language-ruby"},[s("code",[s("span",{staticStyle:{"font-style":"italic"}},[t._v("#! /usr/bin/env ruby")]),t._v("\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("def")]),t._v(" hello\n  puts "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'hello mundo'")]),t._v("\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("end")]),t._v("\n\nhello()")])]),t._v(" "),s("p",[t._v("合并的两边都向这个文件增加了内容，但是导致冲突的原因是其中一些提交修改了文件的同一个地方。")]),t._v(" "),s("p",[t._v("让我们探索一下现在你手边可用来查明这个冲突是如何产生的工具。\n应该如何修复这个冲突看起来或许并不明显。\n这时你需要更多上下文。")]),t._v(" "),s("p",[t._v("一个很有用的工具是带 "),s("code",{staticClass:"literal"},[t._v("--conflict")]),t._v(" 选项的 "),s("code",{staticClass:"literal"},[t._v("git checkout")]),t._v("。\n这会重新检出文件并替换合并冲突标记。\n如果想要重置标记并尝试再次解决它们的话这会很有用。")]),t._v(" "),s("p",[t._v("可以传递给 "),s("code",{staticClass:"literal"},[t._v("--conflict")]),t._v(" 参数 "),s("code",{staticClass:"literal"},[t._v("diff3")]),t._v(" 或 "),s("code",{staticClass:"literal"},[t._v("merge")]),t._v("（默认选项）。\n如果传给它 "),s("code",{staticClass:"literal"},[t._v("diff3")]),t._v("，Git 会使用一个略微不同版本的冲突标记：\n不仅仅只给你 “ours” 和 “theirs” 版本，同时也会有 “base” 版本在中间来给你更多的上下文。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git checkout --conflict=diff3 hello.rb")])]),t._v(" "),s("p",[t._v("一旦我们运行它，文件看起来会像下面这样：")]),t._v(" "),s("pre",{staticClass:"source language-ruby"},[s("code",[s("span",{staticStyle:{"font-style":"italic"}},[t._v("#! /usr/bin/env ruby")]),t._v("\n\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("def")]),t._v(" hello\n  puts "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'hello mundo'")]),t._v("\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("end")]),t._v("\n\nhello()")])]),t._v(" "),s("p",[t._v("如果你喜欢这种格式，可以通过设置 "),s("code",{staticClass:"literal"},[t._v("merge.conflictstyle")]),t._v(" 选项为 "),s("code",{staticClass:"literal"},[t._v("diff3")]),t._v(" 来做为以后合并冲突的默认选项。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git config --global merge.conflictstyle diff3")])]),t._v(" "),s("p",[s("code",{staticClass:"literal"},[t._v("git checkout")]),t._v(" 命令也可以使用 "),s("code",{staticClass:"literal"},[t._v("--ours")]),t._v(" 和 "),s("code",{staticClass:"literal"},[t._v("--theirs")]),t._v(" 选项，这是一种无需合并的快速方式，你可以选择留下一边的修改而丢弃掉另一边修改。")]),t._v(" "),s("p",[t._v("当有二进制文件冲突时这可能会特别有用，因为可以简单地选择一边，或者可以只合并另一个分支的特定文件——可以做一次合并然后在提交前检出一边或另一边的特定文件。")]),t._v(" "),s("h3",{attrs:{id:"合并日志"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并日志"}},[t._v("#")]),t._v(" 合并日志")]),t._v(" "),s("p",[t._v("另一个解决合并冲突有用的工具是 "),s("code",{staticClass:"literal"},[t._v("git log")]),t._v("。\n这可以帮助你得到那些对冲突有影响的上下文。\n回顾一点历史来记起为什么两条线上的开发会触碰同一片代码有时会很有用。")]),t._v(" "),s("p",[t._v("为了得到此次合并中包含的每一个分支的所有独立提交的列表，\n我们可以使用之前在 <"),s("a",{staticClass:"xref",attrs:{id:"xref-_triple_dot",href:"#_triple_dot"}},[t._v("三点")]),t._v(" 学习的“三点”语法。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git log --oneline --left-right HEAD...MERGE_HEAD\n< f1270f7 update README\n< 9af9d3b add a README\n< 694971d update phrase to hola world\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v(" e3eb223 add more tests\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v(" 7cff591 add testing script\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v(" c3ffff1 changed text to hello mundo")])]),t._v(" "),s("p",[t._v("这个漂亮的列表包含 6 个提交和每一个提交所在的不同开发路径。")]),t._v(" "),s("p",[t._v("我们可以通过更加特定的上下文来进一步简化这个列表。\n如果我们添加 "),s("code",{staticClass:"literal"},[t._v("--merge")]),t._v(" 选项到 "),s("code",{staticClass:"literal"},[t._v("git log")]),t._v(" 中，它会只显示任何一边接触了合并冲突文件的提交。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git log --oneline --left-right --merge\n< 694971d update phrase to hola world\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v(">")]),t._v(" c3ffff1 changed text to hello mundo")])]),t._v(" "),s("p",[t._v("如果你运行命令时用 "),s("code",{staticClass:"literal"},[t._v("-p")]),t._v(" 选项代替，你会得到所有冲突文件的区别。\n快速获得你需要帮助理解为什么发生冲突的上下文，以及如何聪明地解决它，这会 "),s("strong",[t._v("非常")]),t._v(" 有用。")]),t._v(" "),s("h3",{attrs:{id:"组合式差异格式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合式差异格式"}},[t._v("#")]),t._v(" 组合式差异格式")]),t._v(" "),s("p",[t._v("因为 Git 暂存合并成功的结果，当你在合并冲突状态下运行 "),s("code",{staticClass:"literal"},[t._v("git diff")]),t._v(" 时，只会得到现在还在冲突状态的区别。\n当需要查看你还需要解决哪些冲突时这很有用。")]),t._v(" "),s("p",[t._v("在合并冲突后直接运行的 "),s("code",{staticClass:"literal"},[t._v("git diff")]),t._v(" 会给你一个相当独特的输出格式。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff\ndiff --cc hello.rb\nindex 0399cd5,59727f0..0000000\n--- a/hello.rb\n+++ b/hello.rb\n@@@ -1,7 -1,7 +1,11 @@@\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("  #")]),t._v("! /usr/bin/env ruby\n\n  def hello\n++<<<<<<< HEAD\n +  puts 'hola world'\n++=======\n+   puts 'hello mundo'\n++>>>>>>> mundo\n  end\n\n  hello()")])]),t._v(" "),s("p",[t._v("这种叫作“组合式差异”的格式会在每一行给你两列数据。\n第一列为你显示 “ours” 分支与工作目录的文件区别（添加或删除），\n第二列显示 “theirs” 分支与工作目录的拷贝区别。")]),t._v(" "),s("p",[t._v("所以在上面的例子中可以看到 "),s("code",{staticClass:"literal"},[t._v("<<<<<<<")]),t._v(" 与 "),s("code",{staticClass:"literal"},[t._v(">>>>>>>")]),t._v(" 行在工作拷贝中但是并不在合并的任意一边中。\n这很有意义，合并工具因为我们的上下文被困住了，它期望我们去移除它们。")]),t._v(" "),s("p",[t._v("如果我们解决冲突再次运行 "),s("code",{staticClass:"literal"},[t._v("git diff")]),t._v("，我们将会看到同样的事情，但是它有一点帮助。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" vim hello.rb\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff\ndiff --cc hello.rb\nindex 0399cd5,59727f0..0000000\n--- a/hello.rb\n+++ b/hello.rb\n@@@ -1,7 -1,7 +1,7 @@@\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("  #")]),t._v("! /usr/bin/env ruby\n\n  def hello\n-   puts 'hola world'\n -  puts 'hello mundo'\n++  puts 'hola mundo'\n  end\n\n  hello()")])]),t._v(" "),s("p",[t._v("这里显示出 “hola world” 在我们这边但不在工作拷贝中，那个 “hello mundo” 在他们那边但不在工作拷贝中，\n最终 “hola mundo” 不在任何一边但是现在在工作拷贝中。在提交解决方案前这对审核很有用。")]),t._v(" "),s("p",[t._v("也可以在合并后通过 "),s("code",{staticClass:"literal"},[t._v("git log")]),t._v(" 来获取相同信息，查看冲突是如何解决的。\n如果你对一个合并提交运行 "),s("code",{staticClass:"literal"},[t._v("git show")]),t._v(" 命令 Git 将会输出这种格式，\n或者你也可以在 "),s("code",{staticClass:"literal"},[t._v("git log -p")]),t._v("（默认情况下该命令只会展示还没有合并的补丁）命令之后加上 "),s("code",{staticClass:"literal"},[t._v("--cc")]),t._v(" 选项。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git log --cc -p -1\ncommit 14f41939956d80b9e17bb8721354c33f8d5b5a79\nMerge: f1270f7 e3eb223\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Sep 19 18:14:49 2014 +0200\n\n    Merge branch 'mundo'\n\n    Conflicts:\n        hello.rb\n\ndiff --cc hello.rb\nindex 0399cd5,59727f0..e1d0799\n--- a/hello.rb\n+++ b/hello.rb\n@@@ -1,7 -1,7 +1,7 @@@\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("  #")]),t._v("! /usr/bin/env ruby\n\n  def hello\n-   puts 'hola world'\n -  puts 'hello mundo'\n++  puts 'hola mundo'\n  end\n\n  hello()")])]),t._v(" "),s("h2",{attrs:{id:"撤消合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#撤消合并"}},[t._v("#")]),t._v(" 撤消合并")]),t._v(" "),s("p",[t._v("虽然你已经知道如何创建一个合并提交，但有时出错是在所难免的。\n使用 Git 最棒的一件事情是犯错是可以的，因为有可能（大多数情况下都很容易）修复它们。")]),t._v(" "),s("p",[t._v("合并提交并无不同。\n假设现在在一个主题分支上工作，不小心将其合并到 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 中，现在提交历史看起来是这样：")]),t._v(" "),s("figure",{staticClass:"image"},[s("div",{staticClass:"content"},[s("img",{attrs:{src:a(424),alt:"意外的合并提交"}})]),t._v(" "),s("figcaption",[t._v("Figure 2. 意外的合并提交")])]),t._v(" "),s("p",[t._v("有两种方法来解决这个问题，这取决于你想要的结果是什么。")]),t._v(" "),s("h3",{attrs:{id:"修复引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#修复引用"}},[t._v("#")]),t._v(" 修复引用")]),t._v(" "),s("p",[t._v("如果这个不想要的合并提交只存在于你的本地仓库中，最简单且最好的解决方案是移动分支到你想要它指向的地方。\n大多数情况下，如果你在错误的 "),s("code",{staticClass:"literal"},[t._v("git merge")]),t._v(" 后运行 "),s("code",{staticClass:"literal"},[t._v("git reset --hard HEAD~")]),t._v("，这会重置分支指向所以它们看起来像这样：")]),t._v(" "),s("figure",{staticClass:"image"},[s("div",{staticClass:"content"},[s("img",{attrs:{src:a(425),alt:"在 `git reset --hard HEAD~` 之后的历史"}})]),t._v(" "),s("figcaption",[t._v("Figure 3. 在 "),s("code",{staticClass:"literal"},[t._v("git reset --hard HEAD~")]),t._v(" 之后的历史")])]),t._v(" "),s("p",[t._v("我们之前在 "),s("a",{staticClass:"xref",attrs:{id:"xref-_git_reset",href:"#_git_reset"}},[t._v("重置揭密")]),t._v(" 已经介绍了 "),s("code",{staticClass:"literal"},[t._v("reset")]),t._v("，所以现在指出这里发生了什么并不是很困难。\n让我们快速复习下："),s("code",{staticClass:"literal"},[t._v("reset --hard")]),t._v(" 通常会经历三步：")]),t._v(" "),s("div",{staticClass:"ordered-list arabic"},[s("ol",{staticClass:"arabic"},[s("li",[s("span",{staticClass:"principal"},[t._v("移动 HEAD 指向的分支。\n在本例中，我们想要移动 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 到合并提交（"),s("code",{staticClass:"literal"},[t._v("C6")]),t._v("）之前所在的位置。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[t._v("使索引看起来像 HEAD。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[t._v("使工作目录看起来像索引。")])])])]),t._v(" "),s("p",[t._v("这个方法的缺点是它会重写历史，在一个共享的仓库中这会造成问题的。\n查阅 "),s("a",{staticClass:"xref",attrs:{id:"xref--ch03-git-branching--_rebase_peril",href:"/chapter-3/6.html#变基的风险"}},[t._v("变基的风险")]),t._v(" 来了解更多可能发生的事情；\n用简单的话说就是如果其他人已经有你将要重写的提交，你应当避免使用 "),s("code",{staticClass:"literal"},[t._v("reset")]),t._v("。\n如果有任何其他提交在合并之后创建了，那么这个方法也会无效；移动引用实际上会丢失那些改动。")]),t._v(" "),s("h3",{attrs:{id:"还原提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#还原提交"}},[t._v("#")]),t._v(" 还原提交")]),t._v(" "),s("p",[t._v("如果移动分支指针并不适合你，Git 给你一个生成一个新提交的选项，提交将会撤消一个已存在提交的所有修改。\nGit 称这个操作为“还原”，在这个特定的场景下，你可以像这样调用它：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git revert -m 1 HEAD\n[master b1d8379] Revert \"Merge branch 'topic'\"")])]),t._v(" "),s("p",[s("code",{staticClass:"literal"},[t._v("-m 1")]),t._v(" 标记指出 “mainline” 需要被保留下来的父结点。\n当你引入一个合并到 "),s("code",{staticClass:"literal"},[t._v("HEAD")]),t._v("（"),s("code",{staticClass:"literal"},[t._v("git merge topic")]),t._v("），新提交有两个父结点：第一个是 "),s("code",{staticClass:"literal"},[t._v("HEAD")]),t._v("（"),s("code",{staticClass:"literal"},[t._v("C6")]),t._v("），第二个是将要合并入分支的最新提交（"),s("code",{staticClass:"literal"},[t._v("C4")]),t._v("）。\n在本例中，我们想要撤消所有由父结点 #2（"),s("code",{staticClass:"literal"},[t._v("C4")]),t._v("）合并引入的修改，同时保留从父结点 #1（"),s("code",{staticClass:"literal"},[t._v("C6")]),t._v("）开始的所有内容。")]),t._v(" "),s("p",[t._v("有还原提交的历史看起来像这样：")]),t._v(" "),s("figure",{staticClass:"image"},[s("div",{staticClass:"content"},[s("img",{attrs:{src:a(426),alt:"在 `git revert -m 1` 后的历史"}})]),t._v(" "),s("figcaption",[t._v("Figure 4. 在 "),s("code",{staticClass:"literal"},[t._v("git revert -m 1")]),t._v(" 后的历史")])]),t._v(" "),s("p",[t._v("新的提交 "),s("code",{staticClass:"literal"},[t._v("^M")]),t._v(" 与 "),s("code",{staticClass:"literal"},[t._v("C6")]),t._v(" 有完全一样的内容，所以从这儿开始就像合并从未发生过，除了“现在还没合并”的提交依然在 "),s("code",{staticClass:"literal"},[t._v("HEAD")]),t._v(" 的历史中。\n如果你尝试再次合并 "),s("code",{staticClass:"literal"},[t._v("topic")]),t._v(" 到 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" Git 会感到困惑：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge topic\nAlready up-to-date.")])]),t._v(" "),s("p",[s("code",{staticClass:"literal"},[t._v("topic")]),t._v(" 中并没有东西不能从 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 中追踪到达。\n更糟的是，如果你在 "),s("code",{staticClass:"literal"},[t._v("topic")]),t._v(" 中增加工作然后再次合并，Git 只会引入被还原的合并 "),s("em",[t._v("之后")]),t._v(" 的修改。")]),t._v(" "),s("figure",{staticClass:"image"},[s("div",{staticClass:"content"},[s("img",{attrs:{src:a(427),alt:"含有坏掉合并的历史"}})]),t._v(" "),s("figcaption",[t._v("Figure 5. 含有坏掉合并的历史")])]),t._v(" "),s("p",[t._v("解决这个最好的方式是撤消还原原始的合并，因为现在你想要引入被还原出去的修改，"),s("strong",[t._v("然后")]),t._v(" 创建一个新的合并提交：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(' git revert ^M\n[master 09f0126] Revert "Revert "Merge branch \'topic\'""\n'),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge topic")])]),t._v(" "),s("figure",{staticClass:"image"},[s("div",{staticClass:"content"},[s("img",{attrs:{src:a(428),alt:"在重新合并一个还原合并后的历史"}})]),t._v(" "),s("figcaption",[t._v("Figure 6. 在重新合并一个还原合并后的历史")])]),t._v(" "),s("p",[t._v("在本例中，"),s("code",{staticClass:"literal"},[t._v("M")]),t._v(" 与 "),s("code",{staticClass:"literal"},[t._v("^M")]),t._v(" 抵消了。\n"),s("code",{staticClass:"literal"},[t._v("^^M")]),t._v(" 事实上合并入了 "),s("code",{staticClass:"literal"},[t._v("C3")]),t._v(" 与 "),s("code",{staticClass:"literal"},[t._v("C4")]),t._v(" 的修改，"),s("code",{staticClass:"literal"},[t._v("C8")]),t._v(" 合并了 "),s("code",{staticClass:"literal"},[t._v("C7")]),t._v(" 的修改，所以现在 "),s("code",{staticClass:"literal"},[t._v("topic")]),t._v(" 已经完全被合并了。")]),t._v(" "),s("h2",{attrs:{id:"其他类型的合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他类型的合并"}},[t._v("#")]),t._v(" 其他类型的合并")]),t._v(" "),s("p",[t._v("到目前为止我们介绍的都是通过一个叫作 “recursive” 的合并策略来正常处理的两个分支的正常合并。\n然而还有其他方式来合并两个分支到一起。\n让我们来快速介绍其中的几个。")]),t._v(" "),s("h3",{attrs:{id:"我们的或他们的偏好"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#我们的或他们的偏好"}},[t._v("#")]),t._v(" 我们的或他们的偏好")]),t._v(" "),s("p",[t._v("首先，有另一种我们可以通过 “recursive” 合并模式做的有用工作。\n我们之前已经看到传递给 "),s("code",{staticClass:"literal"},[t._v("-X")]),t._v(" 的 "),s("code",{staticClass:"literal"},[t._v("ignore-all-space")]),t._v(" 与 "),s("code",{staticClass:"literal"},[t._v("ignore-space-change")]),t._v(" 选项，\n但是我们也可以告诉 Git 当它看见一个冲突时直接选择一边。")]),t._v(" "),s("p",[t._v("默认情况下，当 Git 看到两个分支合并中的冲突时，它会将合并冲突标记添加到你的代码中并标记文件为冲突状态来让你解决。\n如果你希望 Git 简单地选择特定的一边并忽略另外一边而不是让你手动解决冲突，你可以传递给 "),s("code",{staticClass:"literal"},[t._v("merge")]),t._v(" 命令一个 "),s("code",{staticClass:"literal"},[t._v("-Xours")]),t._v(" 或 "),s("code",{staticClass:"literal"},[t._v("-Xtheirs")]),t._v(" 参数。")]),t._v(" "),s("p",[t._v("如果 Git 看到这个，它并不会增加冲突标记。\n任何可以合并的区别，它会直接合并。\n任何有冲突的区别，它会简单地选择你全局指定的一边，包括二进制文件。")]),t._v(" "),s("p",[t._v("如果我们回到之前我们使用的 “hello world” 例子中，我们可以看到合并入我们的分支时引发了冲突。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge mundo\nAuto-merging hello.rb\nCONFLICT (content): Merge conflict in hello.rb\nResolved 'hello.rb' using previous resolution.\nAutomatic merge failed; fix conflicts and then commit the result.")])]),t._v(" "),s("p",[t._v("然而如果我们运行时增加 "),s("code",{staticClass:"literal"},[t._v("-Xours")]),t._v(" 或 "),s("code",{staticClass:"literal"},[t._v("-Xtheirs")]),t._v(" 参数就不会有冲突。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge -Xours mundo\nAuto-merging hello.rb\nMerge made by the 'recursive' strategy.\n hello.rb | 2 +-\n test.sh  | 2 ++\n 2 files changed, 3 insertions(+), 1 deletion(-)\n create mode 100644 test.sh")])]),t._v(" "),s("p",[t._v("在上例中，它并不会为 “hello mundo” 与 “hola world” 标记合并冲突，它只会简单地选取 “hola world”。\n然而，在那个分支上所有其他非冲突的改动都可以被成功地合并入。")]),t._v(" "),s("p",[t._v("这个选项也可以传递给我们之前看到的 "),s("code",{staticClass:"literal"},[t._v("git merge-file")]),t._v(" 命令，\n通过运行类似 "),s("code",{staticClass:"literal"},[t._v("git merge-file --ours")]),t._v(" 的命令来合并单个文件。")]),t._v(" "),s("p",[t._v("如果想要做类似的事情但是甚至并不想让 Git 尝试合并另外一边的修改，\n有一个更严格的选项，它是 “ours” 合并 "),s("em",[t._v("策略")]),t._v("。\n这与 “ours” recursive 合并 "),s("em",[t._v("选项")]),t._v(" 不同。")]),t._v(" "),s("p",[t._v("这本质上会做一次假的合并。\n它会记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支。\n它只会简单地把当前分支的代码当作合并结果记录下来。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge -s ours mundo\nMerge made by the 'ours' strategy.\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff HEAD HEAD~\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")])])]),t._v(" "),s("p",[t._v("你可以看到合并后与合并前我们的分支并没有任何区别。")]),t._v(" "),s("p",[t._v("当再次合并时从本质上欺骗 Git 认为那个分支已经合并过经常是很有用的。\n例如，假设你有一个分叉的 "),s("code",{staticClass:"literal"},[t._v("release")]),t._v(" 分支并且在上面做了一些你想要在未来某个时候合并回 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 的工作。\n与此同时 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支上的某些 bugfix 需要向后移植回 "),s("code",{staticClass:"literal"},[t._v("release")]),t._v(" 分支。\n你可以合并 bugfix 分支进入 "),s("code",{staticClass:"literal"},[t._v("release")]),t._v(" 分支同时也 "),s("code",{staticClass:"literal"},[t._v("merge -s ours")]),t._v(" 合并进入你的 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支\n（即使那个修复已经在那儿了）这样当你之后再次合并 "),s("code",{staticClass:"literal"},[t._v("release")]),t._v(" 分支时，就不会有来自 bugfix 的冲突。")]),t._v(" "),s("h3",{attrs:{id:"子树合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#子树合并"}},[t._v("#")]),t._v(" 子树合并")]),t._v(" "),s("p",[t._v("子树合并的思想是你有两个项目，并且其中一个映射到另一个项目的一个子目录，或者反过来也行。\n当你执行一个子树合并时，Git 通常可以自动计算出其中一个是另外一个的子树从而实现正确的合并。")]),t._v(" "),s("p",[t._v("我们来看一个例子如何将一个项目加入到一个已存在的项目中，然后将第二个项目的代码合并到第一个项目的子目录中。")]),t._v(" "),s("p",[t._v("首先，我们将 Rack 应用添加到你的项目里。\n我们把 Rack 项目作为一个远程的引用添加到我们的项目里，然后检出到它自己的分支。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git remote add rack_remote https://github.com/rack/rack\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git fetch rack_remote --no-tags\nwarning: no common commits\nremote: Counting objects: 3184, done.\nremote: Compressing objects: 100% (1465/1465), done.\nremote: Total 3184 (delta 1952), reused 2770 (delta 1675)\nReceiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.\nResolving deltas: 100% (1952/1952), done.\nFrom https://github.com/rack/rack\n * [new branch]      build      -> rack_remote/build\n * [new branch]      master     -> rack_remote/master\n * [new branch]      rack-0.4   -> rack_remote/rack-0.4\n * [new branch]      rack-0.9   -> rack_remote/rack-0.9\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(' git checkout -b rack_branch rack_remote/master\nBranch rack_branch set up to track remote branch refs/remotes/rack_remote/master.\nSwitched to a new branch "rack_branch"')])]),t._v(" "),s("p",[t._v("现在在我们的 "),s("code",{staticClass:"literal"},[t._v("rack_branch")]),t._v(" 分支里就有 Rack 项目的根目录，而我们的项目则在 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支里。\n如果你从一个分支切换到另一个分支，你可以看到它们的项目根目录是不同的：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" ls\nAUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib\nCOPYING         README         bin           example         test\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(' git checkout master\nSwitched to branch "master"\n'),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" ls\nREADME")])]),t._v(" "),s("p",[t._v("这个是一个比较奇怪的概念。\n并不是仓库中的所有分支都是必须属于同一个项目的分支.\n这并不常见，因为没啥用，但是却是在不同分支里包含两条完全不同提交历史的最简单的方法。")]),t._v(" "),s("p",[t._v("在这个例子中，我们希望将 Rack 项目拉到 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 项目中作为一个子目录。\n我们可以在 Git 中执行 "),s("code",{staticClass:"literal"},[t._v("git read-tree")]),t._v(" 来实现。\n你可以在 "),s("a",{staticClass:"xref",attrs:{href:"/chapter-10/index.html"}},[t._v("Git 内部原理")]),t._v(" 中查看更多 "),s("code",{staticClass:"literal"},[t._v("read-tree")]),t._v(" 的相关信息，现在你只需要知道它会读取一个分支的根目录树到当前的暂存区和工作目录里。\n先切回你的 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支，将 "),s("code",{staticClass:"literal"},[t._v("rack_back")]),t._v(" 分支拉取到我们项目的 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支中的 "),s("code",{staticClass:"literal"},[t._v("rack")]),t._v(" 子目录。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git read-tree --prefix=rack/ -u rack_branch")])]),t._v(" "),s("p",[t._v("当我们提交时，那个子目录中拥有所有 Rack 项目的文件 —— 就像我们直接从压缩包里复制出来的一样。\n有趣的是你可以很容易地将一个分支的变更合并到另一个分支里。\n所以，当 Rack 项目有更新时，我们可以切换到那个分支来拉取上游的变更。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git checkout rack_branch\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git pull")])]),t._v(" "),s("p",[t._v("接着，我们可以将这些变更合并回我们的 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支。\n使用 "),s("code",{staticClass:"literal"},[t._v("--squash")]),t._v(" 选项和使用 "),s("code",{staticClass:"literal"},[t._v("-Xsubtree")]),t._v(" 选项（它采用递归合并策略），\n都可以用来可以拉取变更并且预填充提交信息。\n（递归策略在这里是默认的，提到它是为了让读者有个清晰的概念。）")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git checkout master\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git merge --squash -s recursive -Xsubtree=rack rack_branch\nSquash commit -- not updating HEAD\nAutomatic merge went well; stopped before committing as requested")])]),t._v(" "),s("p",[t._v("Rack 项目中所有的改动都被合并了，等待被提交到本地。\n你也可以用相反的方法——在 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支上的 "),s("code",{staticClass:"literal"},[t._v("rack")]),t._v(" 子目录中做改动然后将它们合并入你的\n"),s("code",{staticClass:"literal"},[t._v("rack_branch")]),t._v(" 分支中，之后你可能将其提交给项目维护着或者将它们推送到上游。")]),t._v(" "),s("p",[t._v("这给我们提供了一种类似子模块工作流的工作方式，但是它并不需要用到子模块\n（有关子模块的内容我们会在 "),s("a",{staticClass:"xref",attrs:{id:"xref-_git_submodules",href:"#_git_submodules"}},[t._v("子模块")]),t._v(" 中介绍）。\n我们可以在自己的仓库中保持一些和其他项目相关的分支，偶尔使用子树合并将它们合并到我们的项目中。\n某些时候这种方式很有用，例如当所有的代码都提交到一个地方的时候。\n然而，它同时也有缺点，它更加复杂且更容易让人犯错，例如重复合并改动或者不小心将分支提交到一个无关的仓库上去。")]),t._v(" "),s("p",[t._v("另外一个有点奇怪的地方是，当你想查看 "),s("code",{staticClass:"literal"},[t._v("rack")]),t._v(" 子目录和 "),s("code",{staticClass:"literal"},[t._v("rack_branch")]),t._v(" 分支的差异——\n来确定你是否需要合并它们——你不能使用普通的 "),s("code",{staticClass:"literal"},[t._v("diff")]),t._v(" 命令。\n取而代之的是，你必须使用 "),s("code",{staticClass:"literal"},[t._v("git diff-tree")]),t._v(" 来和你的目标分支做比较：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff-tree -p rack_branch")])]),t._v(" "),s("p",[t._v("或者，将你的 "),s("code",{staticClass:"literal"},[t._v("rack")]),t._v(" 子目和最近一次从服务器上抓取的 "),s("code",{staticClass:"literal"},[t._v("master")]),t._v(" 分支进行比较，你可以运行：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git diff-tree -p rack_remote/master")])])])}),[],!1,null,null,null);e.default=l.exports}}]);