(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{535:function(t,a,s){"use strict";s.r(a);var i=s(28),l=Object(i.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"凭证存储"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#凭证存储"}},[t._v("#")]),t._v(" 凭证存储")]),t._v(" "),s("p"),s("p",[t._v("如果你使用的是 SSH 方式连接远端，并且设置了一个没有口令的密钥，这样就可以在不输入用户名和密码的情况下安全地传输数据。\n然而，这对 HTTP 协议来说是不可能的 —— 每一个连接都是需要用户名和密码的。\n这在使用双重认证的情况下会更麻烦，因为你需要输入一个随机生成并且毫无规律的 token 作为密码。")]),t._v(" "),s("p",[t._v("幸运的是，Git 拥有一个凭证系统来处理这个事情。\n下面有一些 Git 的选项：")]),t._v(" "),s("div",{staticClass:"itemized-list"},[s("ul",[s("li",[s("span",{staticClass:"principal"},[t._v("默认所有都不缓存。\n每一次连接都会询问你的用户名和密码。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[t._v("“cache” 模式会将凭证存放在内存中一段时间。\n密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[t._v("“store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。\n这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。\n这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[t._v("如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中。\n这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[t._v("如果你使用的是 Windows，你可以安装一个叫做 “Git Credential Manager for Windows” 的辅助工具。\n这和上面说的 “osxkeychain” 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。\n可以在 "),s("a",{staticClass:"link",attrs:{href:"https://github.com/Microsoft/Git-Credential-Manager-for-Windows"}},[t._v("https://github.com/Microsoft/Git-Credential-Manager-for-Windows")]),t._v(" 下载。")])])])]),t._v(" "),s("p",[t._v("你可以设置 Git 的配置来选择上述的一种方式")]),s("p"),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git config --global credential.helper cache")])]),t._v(" "),s("p",[t._v("部分辅助工具有一些选项。\n“store” 模式可以接受一个 "),s("code",{staticClass:"literal"},[t._v("--file <path>")]),t._v(" 参数，可以自定义存放密码的文件路径（默认是 "),s("code",{staticClass:"literal"},[t._v("~/.git-credentials")]),t._v(" ）。\n“cache” 模式有 "),s("code",{staticClass:"literal"},[t._v("--timeout <seconds>")]),t._v(" 参数，可以设置后台进程的存活时间（默认是 “900”，也就是 15 分钟）。\n下面是一个配置 “store” 模式自定义路径的例子：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git config --global credential.helper "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'store --file ~/.my-credentials'")])])]),t._v(" "),s("p",[t._v("Git 甚至允许你配置多个辅助工具。\n当查找特定服务器的凭证时，Git 会按顺序查询，并且在找到第一个回答时停止查询。\n当保存凭证时，Git 会将用户名和密码发送给 "),s("strong",[t._v("所有")]),t._v(" 配置列表中的辅助工具，它们会按自己的方式处理用户名和密码。\n如果你在闪存上有一个凭证文件，但又希望在该闪存被拔出的情况下使用内存缓存来保存用户名密码，"),s("code",{staticClass:"literal"},[t._v(".gitconfig")]),t._v(" 配置文件如下：")]),t._v(" "),s("pre",{staticClass:"source language-ini"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("[credential]")]),t._v("\n    helper = "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("store --file /mnt/thumbdrive/.git-credentials")]),t._v("\n"),s("span",{staticStyle:{"font-style":"italic"}},[t._v("    helper = cache --timeout 30000")])])]),t._v(" "),s("h2",{attrs:{id:"底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#底层实现"}},[t._v("#")]),t._v(" 底层实现")]),t._v(" "),s("p",[t._v("这些是如何实现的呢？\nGit 凭证辅助工具系统的命令是 "),s("code",{staticClass:"literal"},[t._v("git credential")]),t._v("，这个命令接收一个参数，并通过标准输入获取更多的参数。")]),t._v(" "),s("p",[t._v("举一个例子更容易理解。\n我们假设已经配置好一个凭证辅助工具，这个辅助工具保存了 "),s("code",{staticClass:"literal"},[t._v("mygithost")]),t._v(" 的凭证信息。\n下面是一个使用 “fill” 命令的会话，当 Git 尝试寻找一个服务器的凭证时就会被调用。")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git credential fill "),s("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v("\nprotocol=https "),s("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v("\nhost=mygithost\n "),s("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v("\nprotocol=https "),s("i",{staticClass:"conum",attrs:{"data-value":"4"}},[t._v("④")]),t._v("\nhost=mygithost\nusername=bob\npassword=s3cre7\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git credential fill "),s("i",{staticClass:"conum",attrs:{"data-value":"5"}},[t._v("⑤")]),t._v("\nprotocol=https\nhost=unknownhost\n\nUsername for 'https://unknownhost': bob\nPassword for 'https://bob@unknownhost':\nprotocol=https\nhost=unknownhost\nusername=bob\npassword=s3cre7")])]),t._v(" "),s("div",{staticClass:"callout-list"},[s("ol",[s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v(" 这是开始交互的命令。")]),t._v(" "),s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v(" Git-credential 接下来会等待标准输入。\n我们提供我们所知道的信息：协议和主机名。")]),t._v(" "),s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v(" 一个空行代表输入已经完成，凭证系统应该输出它所知道的信息。")]),t._v(" "),s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"4"}},[t._v("④")]),t._v(" 接下来由 Git-credential 接管，并且将找到的信息打印到标准输出。")]),t._v(" "),s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"5"}},[t._v("⑤")]),t._v(" 如果没有找到对应的凭证，Git 会询问用户的用户名和密码，我们将这些信息输入到在标准输出的地方（这个例子中是同一个控制台）。")])])]),t._v(" "),s("p",[t._v("凭证系统实际调用的程序和 Git 本身是分开的；具体是哪一个以及如何调用与 "),s("code",{staticClass:"literal"},[t._v("credential.helper")]),t._v(" 配置的值有关。\n这个配置有多种格式：")]),t._v(" "),s("div",{staticClass:"table"},[s("div",{staticClass:"content"},[s("table",{staticClass:"table table-framed-topbot table-grid-rows",staticStyle:{width:"100%"}},[s("colgroup",[s("col"),t._v(" "),s("col")]),t._v(" "),s("thead",[s("tr",[s("th",[t._v("配置值")]),t._v(" "),s("th",[t._v("行为")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("p",[s("code",{staticClass:"literal"},[t._v("foo")])])]),t._v(" "),s("td",[s("p",[t._v("执行 "),s("code",{staticClass:"literal"},[t._v("git-credential-foo")])])])]),t._v(" "),s("tr",[s("td",[s("p",[s("code",{staticClass:"literal"},[t._v("foo -a --opt=bcd")])])]),t._v(" "),s("td",[s("p",[t._v("执行 "),s("code",{staticClass:"literal"},[t._v("git-credential-foo -a --opt=bcd")])])])]),t._v(" "),s("tr",[s("td",[s("p",[s("code",{staticClass:"literal"},[t._v("/absolute/path/foo -xyz")])])]),t._v(" "),s("td",[s("p",[t._v("执行 "),s("code",{staticClass:"literal"},[t._v("/absolute/path/foo -xyz")])])])]),t._v(" "),s("tr",[s("td",[s("p",[s("code",{staticClass:"literal"},[t._v('!f() { echo "password=s3cre7"; }; f')])])]),t._v(" "),s("td",[s("p",[s("code",{staticClass:"literal"},[t._v("!")]),t._v(" 后面的代码会在 shell 执行")])])])])])])]),t._v(" "),s("p",[t._v("上面描述的辅助工具可以被称做 "),s("code",{staticClass:"literal"},[t._v("git-credential-cache")]),t._v("、"),s("code",{staticClass:"literal"},[t._v("git-credential-store")]),t._v(" 之类，我们可以配置它们来接受命令行参数。\n通常的格式是 “git-credential-foo [args] <action>”\n标准输入/输出协议和 git-credential 一样，但它们使用的是一套稍微不太一样的行为：")]),t._v(" "),s("div",{staticClass:"itemized-list"},[s("ul",[s("li",[s("span",{staticClass:"principal"},[s("code",{staticClass:"literal"},[t._v("get")]),t._v(" 是请求输入一对用户名和密码。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[s("code",{staticClass:"literal"},[t._v("store")]),t._v(" 是请求保存一个凭证到辅助工具的内存。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[s("code",{staticClass:"literal"},[t._v("erase")]),t._v(" 会将给定的证书从辅助工具内存中清除。")])])])]),t._v(" "),s("p",[t._v("对于 "),s("code",{staticClass:"literal"},[t._v("store")]),t._v(" 和 "),s("code",{staticClass:"literal"},[t._v("erase")]),t._v(" 两个行为是不需要返回数据的（Git 也会忽略掉）。\n然而对于 "),s("code",{staticClass:"literal"},[t._v("get")]),t._v("，Git 对辅助工具的返回信息十分感兴趣。\n如果辅助工具并不知道任何有用的信息，它就会直接退出而没有任何输出，但如果知道的话，\n它就会在已存储信息的基础上扩充所提供的信息。\n它的输出可看做一系列赋值语句，提供的任何内容都会取代 Git 已知的内容。")]),t._v(" "),s("p",[t._v("如果辅助工具没有任何有用的信息，它可以直接退出而不需要输出任何东西，但如果它有这些信息，它在提供的信息后面增加它所拥有的信息。\n这些输出会被视为一系列的赋值语句；每一个提供的数据都会将 Git 已有的数据替换掉。")]),t._v(" "),s("p",[t._v("这有一个和上面一样的例子，但是跳过了 git-credential 这一步，直接到 git-credential-store:")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git credential-store --file ~/git.store store "),s("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v("\nprotocol=https\nhost=mygithost\nusername=bob\npassword=s3cre7\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git credential-store --file ~/git.store get "),s("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v("\nprotocol=https\nhost=mygithost\n\nusername=bob "),s("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v("\npassword=s3cre7")])]),t._v(" "),s("div",{staticClass:"callout-list"},[s("ol",[s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v(" 我们告诉 "),s("code",{staticClass:"literal"},[t._v("git-credential-store")]),t._v(" 去保存凭证：当访问 "),s("code",{staticClass:"literal"},[t._v("https://mygithost")]),t._v(" 时使用用户名 “bob”，密码是 “s3cre7”。")]),t._v(" "),s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v(" 现在我们取出这个凭证。\n我们提供连接这部分的信息（"),s("code",{staticClass:"literal"},[t._v("https://mygithost")]),t._v("）以及一个空行。")]),t._v(" "),s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v(" "),s("code",{staticClass:"literal"},[t._v("git-credential-store")]),t._v(" 输出我们之前保存的用户名和密码。")])])]),t._v(" "),s("p",[s("code",{staticClass:"literal"},[t._v("~/git.store")]),t._v(" 文件的内容类似：")]),t._v(" "),s("pre",{staticClass:"source language-ini"},[s("code",[t._v("https://bob:s3cre7@mygithost")])]),t._v(" "),s("p",[t._v("仅仅是一系列包含凭证信息 URL 组成的行。\n"),s("code",{staticClass:"literal"},[t._v("osxkeychain")]),t._v(" 和 "),s("code",{staticClass:"literal"},[t._v("wincred")]),t._v(" 辅助工具使用它们后端存储的原生格式，而 "),s("code",{staticClass:"literal"},[t._v("cache")]),t._v(" 使用它的内存格式（其他进程无法读取）。")]),t._v(" "),s("h2",{attrs:{id:"自定义凭证缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义凭证缓存"}},[t._v("#")]),t._v(" 自定义凭证缓存")]),t._v(" "),s("p",[t._v("已经知道 "),s("code",{staticClass:"literal"},[t._v("git-credential-store")]),t._v(" 之类的是和 Git 是相互独立的程序，就不难理解 Git 凭证辅助工具可以是 "),s("em",[t._v("任意")]),t._v(" 程序。\n虽然 Git 提供的辅助工具覆盖了大多数常见的使用场景，但并不能满足所有情况。\n比如，假设你的整个团队共享一些凭证，也许是在部署时使用。\n这些凭证是保存在一个共享目录里，由于这些凭证经常变更，所以你不想把它们复制到你自己的凭证仓库中。\n现有的辅助工具无法满足这种情况；来看看我们如何自己实现一个。\n这个程序应该拥有几个核心功能：")]),t._v(" "),s("div",{staticClass:"ordered-list arabic"},[s("ol",{staticClass:"arabic"},[s("li",[s("span",{staticClass:"principal"},[t._v("我们唯一需要关注的行为是 "),s("code",{staticClass:"literal"},[t._v("get")]),t._v("；"),s("code",{staticClass:"literal"},[t._v("store")]),t._v(" 和 "),s("code",{staticClass:"literal"},[t._v("erase")]),t._v(" 是写操作，所以当接受到这两个请求时我们直接退出即可。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[t._v("共享的凭证文件格式和 "),s("code",{staticClass:"literal"},[t._v("git-credential-store")]),t._v(" 使用的格式相同。")])]),t._v(" "),s("li",[s("span",{staticClass:"principal"},[t._v("凭证文件的路径一般是固定的，但我们应该允许用户传入一个自定义路径以防万一。")])])])]),t._v(" "),s("p",[t._v("我们再一次使用 Ruby 来编写这个扩展，但只要 Git 能够执行最终的程序，任何语言都是可以的。\n这是我们的凭证辅助工具的完整代码：")]),t._v(" "),s("pre",{staticClass:"source language-ruby"},[s("code",[s("span",{staticStyle:{"font-style":"italic"}},[t._v("#!/usr/bin/env ruby")]),t._v("\n\nrequire "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'optparse'")]),t._v("\n\npath = File.expand_path "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'~/.git-credentials'")]),t._v(" "),s("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v("\nOptionParser.new "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("do")]),t._v(" |opts|\n    opts.banner = "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'USAGE: git-credential-read-only [options] <action>'")]),t._v("\n    opts.on("),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'-f'")]),t._v(", "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'--file PATH'")]),t._v(", "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'Specify path for backing store'")]),t._v(") "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("do")]),t._v(" |argpath|\n        path = File.expand_path argpath\n    "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("end")]),t._v("\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("end")]),t._v(".parse!\n\nexit(0) "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("unless")]),t._v(" ARGV[0].downcase == "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'get'")]),t._v(" "),s("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v("\nexit(0) "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("unless")]),t._v(" File.exists? path\n\nknown = {} "),s("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v("\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("while")]),t._v(" line = STDIN.gets\n    "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("break")]),t._v(" "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("if")]),t._v(" line.strip == "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("''")]),t._v("\n    k,v = line.strip.split "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'='")]),t._v(", 2\n    known[k] = v\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("end")]),t._v("\n\nFile.readlines(path).each "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("do")]),t._v(" |fileline| "),s("i",{staticClass:"conum",attrs:{"data-value":"4"}},[t._v("④")]),t._v("\n    prot,user,pass,host = fileline.scan("),s("span",{staticStyle:{"font-style":"italic"}},[t._v("/^(.*?):\\/\\/(.*?):(.*?)@(.*)$/")]),t._v(").first\n    "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("if")]),t._v(" prot == known["),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'protocol'")]),t._v("] "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("and")]),t._v(" host == known["),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'host'")]),t._v("] "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("and")]),t._v(" user == known["),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'username'")]),t._v("] "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("then")]),t._v("\n        puts "),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"protocol=')]),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("#{")]),t._v("prot"),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("}")]),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"')]),t._v("\n        puts "),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"host=')]),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("#{")]),t._v("host"),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("}")]),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"')]),t._v("\n        puts "),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"username=')]),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("#{")]),t._v("user"),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("}")]),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"')]),t._v("\n        puts "),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"password=')]),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("#{")]),t._v("pass"),s("span",{staticStyle:{"font-weight":"bold","font-style":"italic"}},[t._v("}")]),s("span",{staticStyle:{"font-style":"italic"}},[t._v('"')]),t._v("\n        exit(0)\n    "),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("end")]),t._v("\n"),s("span",{staticStyle:{"font-weight":"bold"}},[t._v("end")])])]),t._v(" "),s("div",{staticClass:"callout-list"},[s("ol",[s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"1"}},[t._v("①")]),t._v(" 我们在这里解析命令行参数，允许用户指定输入文件，默认是 "),s("code",{staticClass:"literal"},[t._v("~/.git-credentials")]),t._v(".")]),t._v(" "),s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"2"}},[t._v("②")]),t._v(" 这个程序只有在接受到 "),s("code",{staticClass:"literal"},[t._v("get")]),t._v(" 行为的请求并且后端存储的文件存在时才会有输出。")]),t._v(" "),s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"3"}},[t._v("③")]),t._v(" 这个循环从标准输入读取数据，直到读取到第一个空行。\n输入的数据被保存到 "),s("code",{staticClass:"literal"},[t._v("known")]),t._v(" 哈希表中，之后需要用到。")]),t._v(" "),s("li",[s("i",{staticClass:"conum",attrs:{"data-value":"4"}},[t._v("④")]),t._v(" 这个循环读取存储文件中的内容，寻找匹配的行。\n如果 "),s("code",{staticClass:"literal"},[t._v("known")]),t._v(" 中的协议和主机名与该行相匹配，这个程序输出结果并退出。")])])]),t._v(" "),s("p",[t._v("我们把这个辅助工具保存为 "),s("code",{staticClass:"literal"},[t._v("git-credential-read-only")]),t._v("，放到我们的 "),s("code",{staticClass:"literal"},[t._v("PATH")]),t._v(" 路径下并且给予执行权限。\n一个交互式会话类似：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git credential-read-only --file=/mnt/shared/creds get\nprotocol=https\nhost=mygithost\n\nprotocol=https\nhost=mygithost\nusername=bob\npassword=s3cre7")])]),t._v(" "),s("p",[t._v("由于这个的名字是 “git-” 开头，所以我们可以在配置值中使用简便的语法：")]),t._v(" "),s("pre",{staticClass:"language-bash"},[s("code",[s("span",{staticStyle:{"font-weight":"bold"}},[t._v("$")]),t._v(" git config --global credential.helper "),s("span",{staticStyle:{"font-style":"italic"}},[t._v("'read-only --file /mnt/shared/creds'")])])]),t._v(" "),s("p",[t._v("正如你看到的，扩展这个系统是相当简单的，并且可以为你和你的团队解决一些常见问题。")])])}),[],!1,null,null,null);a.default=l.exports}}]);