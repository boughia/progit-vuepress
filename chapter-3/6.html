<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>变基 | Pro Git</title>
    <meta name="description" content="Pro Git 第二版中文版">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.130772cc.css" as="style"><link rel="preload" href="/assets/js/app.e343c26e.js" as="script"><link rel="preload" href="/assets/js/2.c0327591.js" as="script"><link rel="preload" href="/assets/js/7.225eae41.js" as="script"><link rel="prefetch" href="/assets/js/10.0f9cab2e.js"><link rel="prefetch" href="/assets/js/100.83085317.js"><link rel="prefetch" href="/assets/js/101.56c6cce3.js"><link rel="prefetch" href="/assets/js/102.415183d7.js"><link rel="prefetch" href="/assets/js/103.65e1f37c.js"><link rel="prefetch" href="/assets/js/104.4844f2f3.js"><link rel="prefetch" href="/assets/js/105.66c87d19.js"><link rel="prefetch" href="/assets/js/106.05b2e48e.js"><link rel="prefetch" href="/assets/js/107.929c5d0f.js"><link rel="prefetch" href="/assets/js/108.7b376e69.js"><link rel="prefetch" href="/assets/js/109.1a730133.js"><link rel="prefetch" href="/assets/js/11.a6d7b909.js"><link rel="prefetch" href="/assets/js/110.191355ad.js"><link rel="prefetch" href="/assets/js/111.a049971f.js"><link rel="prefetch" href="/assets/js/112.482ffc61.js"><link rel="prefetch" href="/assets/js/113.d94b639c.js"><link rel="prefetch" href="/assets/js/114.8b9356fb.js"><link rel="prefetch" href="/assets/js/115.ebf1e18a.js"><link rel="prefetch" href="/assets/js/116.18b899b1.js"><link rel="prefetch" href="/assets/js/117.42a1b8c4.js"><link rel="prefetch" href="/assets/js/118.3a9d2ee3.js"><link rel="prefetch" href="/assets/js/119.4020833f.js"><link rel="prefetch" href="/assets/js/12.5d2796d3.js"><link rel="prefetch" href="/assets/js/120.9fae7990.js"><link rel="prefetch" href="/assets/js/121.cb3ef973.js"><link rel="prefetch" href="/assets/js/13.f69c9e48.js"><link rel="prefetch" href="/assets/js/14.6debe4be.js"><link rel="prefetch" href="/assets/js/15.a7c94022.js"><link rel="prefetch" href="/assets/js/16.6609021c.js"><link rel="prefetch" href="/assets/js/17.34ba32b5.js"><link rel="prefetch" href="/assets/js/18.4dd74348.js"><link rel="prefetch" href="/assets/js/19.2f410429.js"><link rel="prefetch" href="/assets/js/20.16ec0bd3.js"><link rel="prefetch" href="/assets/js/21.ad1ca29b.js"><link rel="prefetch" href="/assets/js/22.293aa5c6.js"><link rel="prefetch" href="/assets/js/23.025d3c7a.js"><link rel="prefetch" href="/assets/js/24.770fb3e1.js"><link rel="prefetch" href="/assets/js/25.6ce5a0ac.js"><link rel="prefetch" href="/assets/js/26.6404265b.js"><link rel="prefetch" href="/assets/js/27.62decef4.js"><link rel="prefetch" href="/assets/js/28.d1136794.js"><link rel="prefetch" href="/assets/js/29.95a71153.js"><link rel="prefetch" href="/assets/js/3.c6496835.js"><link rel="prefetch" href="/assets/js/30.eae133de.js"><link rel="prefetch" href="/assets/js/31.a6e572c3.js"><link rel="prefetch" href="/assets/js/32.4fc54ce1.js"><link rel="prefetch" href="/assets/js/33.d1c0ecba.js"><link rel="prefetch" href="/assets/js/34.29586ee8.js"><link rel="prefetch" href="/assets/js/35.8e480916.js"><link rel="prefetch" href="/assets/js/36.5b537183.js"><link rel="prefetch" href="/assets/js/37.40c06fd9.js"><link rel="prefetch" href="/assets/js/38.555815d4.js"><link rel="prefetch" href="/assets/js/39.6d5293e5.js"><link rel="prefetch" href="/assets/js/4.e8424aa9.js"><link rel="prefetch" href="/assets/js/40.78797741.js"><link rel="prefetch" href="/assets/js/41.ac76af08.js"><link rel="prefetch" href="/assets/js/42.e7d51b5d.js"><link rel="prefetch" href="/assets/js/43.b20d0fd6.js"><link rel="prefetch" href="/assets/js/44.e29a7c46.js"><link rel="prefetch" href="/assets/js/45.cdea70ee.js"><link rel="prefetch" href="/assets/js/46.9c95c270.js"><link rel="prefetch" href="/assets/js/47.ba588e60.js"><link rel="prefetch" href="/assets/js/48.a8b188ed.js"><link rel="prefetch" href="/assets/js/49.5c609647.js"><link rel="prefetch" href="/assets/js/5.b1d6f09c.js"><link rel="prefetch" href="/assets/js/50.662cc18e.js"><link rel="prefetch" href="/assets/js/51.5ff994dd.js"><link rel="prefetch" href="/assets/js/52.b1b6dd6c.js"><link rel="prefetch" href="/assets/js/53.bd783506.js"><link rel="prefetch" href="/assets/js/54.a05ff5b6.js"><link rel="prefetch" href="/assets/js/55.c30a6cad.js"><link rel="prefetch" href="/assets/js/56.44021f37.js"><link rel="prefetch" href="/assets/js/57.90e56f36.js"><link rel="prefetch" href="/assets/js/58.9ec15505.js"><link rel="prefetch" href="/assets/js/59.8f4ffc72.js"><link rel="prefetch" href="/assets/js/6.49fca771.js"><link rel="prefetch" href="/assets/js/60.8064b38b.js"><link rel="prefetch" href="/assets/js/61.d570ac20.js"><link rel="prefetch" href="/assets/js/62.c66ac933.js"><link rel="prefetch" href="/assets/js/63.d01f285e.js"><link rel="prefetch" href="/assets/js/64.a04e3c07.js"><link rel="prefetch" href="/assets/js/65.af0f13b3.js"><link rel="prefetch" href="/assets/js/66.f81074cc.js"><link rel="prefetch" href="/assets/js/67.47db8798.js"><link rel="prefetch" href="/assets/js/68.50332586.js"><link rel="prefetch" href="/assets/js/69.059056ac.js"><link rel="prefetch" href="/assets/js/70.c46fd0e9.js"><link rel="prefetch" href="/assets/js/71.d45f53f9.js"><link rel="prefetch" href="/assets/js/72.eef7975a.js"><link rel="prefetch" href="/assets/js/73.d947c914.js"><link rel="prefetch" href="/assets/js/74.cc528edb.js"><link rel="prefetch" href="/assets/js/75.7e89a25f.js"><link rel="prefetch" href="/assets/js/76.68b7cb39.js"><link rel="prefetch" href="/assets/js/77.f51671b0.js"><link rel="prefetch" href="/assets/js/78.d940a766.js"><link rel="prefetch" href="/assets/js/79.657d22ce.js"><link rel="prefetch" href="/assets/js/8.1c488769.js"><link rel="prefetch" href="/assets/js/80.b7eef56c.js"><link rel="prefetch" href="/assets/js/81.5a9ab73c.js"><link rel="prefetch" href="/assets/js/82.82f8101f.js"><link rel="prefetch" href="/assets/js/83.16c731ea.js"><link rel="prefetch" href="/assets/js/84.ebb4499e.js"><link rel="prefetch" href="/assets/js/85.323932c6.js"><link rel="prefetch" href="/assets/js/86.5fe42af0.js"><link rel="prefetch" href="/assets/js/87.1e607b95.js"><link rel="prefetch" href="/assets/js/88.1cb1bb53.js"><link rel="prefetch" href="/assets/js/89.30b0fda7.js"><link rel="prefetch" href="/assets/js/9.c748d72e.js"><link rel="prefetch" href="/assets/js/90.050be28f.js"><link rel="prefetch" href="/assets/js/91.57dee3b4.js"><link rel="prefetch" href="/assets/js/92.5ec93ebb.js"><link rel="prefetch" href="/assets/js/93.5a3e28cc.js"><link rel="prefetch" href="/assets/js/94.ab209645.js"><link rel="prefetch" href="/assets/js/95.2a4ea0e2.js"><link rel="prefetch" href="/assets/js/96.41db9364.js"><link rel="prefetch" href="/assets/js/97.b936622c.js"><link rel="prefetch" href="/assets/js/98.32537222.js"><link rel="prefetch" href="/assets/js/99.64a3e64d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.130772cc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Pro Git</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">引言</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-1/" class="sidebar-heading clickable"><span>1. 起步</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-2/" class="sidebar-heading clickable"><span>2. Git 基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-3/" class="sidebar-heading clickable router-link-active open"><span>3. Git 分支</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/chapter-3/1.html" class="sidebar-link">分支简介</a></li><li><a href="/chapter-3/2.html" class="sidebar-link">分支的新建与合并</a></li><li><a href="/chapter-3/3.html" class="sidebar-link">分支管理</a></li><li><a href="/chapter-3/4.html" class="sidebar-link">分支开发工作流</a></li><li><a href="/chapter-3/5.html" class="sidebar-link">远程分支</a></li><li><a href="/chapter-3/6.html" class="active sidebar-link">变基</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/chapter-3/6.html#变基的基本操作" class="sidebar-link">变基的基本操作</a></li><li class="sidebar-sub-header"><a href="/chapter-3/6.html#更有趣的变基例子" class="sidebar-link">更有趣的变基例子</a></li><li class="sidebar-sub-header"><a href="/chapter-3/6.html#变基的风险" class="sidebar-link">变基的风险</a></li><li class="sidebar-sub-header"><a href="/chapter-3/6.html#用变基解决变基" class="sidebar-link">用变基解决变基</a></li><li class="sidebar-sub-header"><a href="/chapter-3/6.html#变基-vs-合并" class="sidebar-link">变基 vs. 合并</a></li></ul></li><li><a href="/chapter-3/7.html" class="sidebar-link">总结</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-4/" class="sidebar-heading clickable"><span>4. 服务器上的 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-5/" class="sidebar-heading clickable"><span>5. 分布式 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-6/" class="sidebar-heading clickable"><span>6. GitHub</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-7/" class="sidebar-heading clickable"><span>7. Git 工具</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-8/" class="sidebar-heading clickable"><span>8. 自定义 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-9/" class="sidebar-heading clickable"><span>9. Git 与其他系统</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-10/" class="sidebar-heading clickable"><span>10. Git 内部原理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/appendix-A/" class="sidebar-heading clickable"><span>附录 A. 在其它环境中使用 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/appendix-B/" class="sidebar-heading clickable"><span>附录 B. 在你的应用中嵌入 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/appendix-C/" class="sidebar-heading clickable"><span>附录 C. Git 命令</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="变基"><a href="#变基" class="header-anchor">#</a> 变基</h1> <p>
在 Git 中整合来自不同分支的修改主要有两种方法：<code class="literal">merge</code> 以及 <code class="literal">rebase</code>。
在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。</p> <h2 id="变基的基本操作"><a href="#变基的基本操作" class="header-anchor">#</a> 变基的基本操作</h2> <p>请回顾之前在 <a id="xref-_basic_merging" href="#_basic_merging" class="xref">分支的合并</a> 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。</p> <figure class="image"><div class="content"><img src="/assets/img/basic-rebase-1.8426b3b9.png" alt="分叉的提交历史。"></div> <figcaption>Figure 27. 分叉的提交历史</figcaption></figure> <p>之前介绍过，整合分支最容易的方法是 <code class="literal">merge</code> 命令。
它会把两个分支的最新快照（<code class="literal">C3</code> 和 <code class="literal">C4</code>）以及二者最近的共同祖先（<code class="literal">C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p> <figure id="ebasing-merging-example" class="image"><div class="content"><img src="/assets/img/basic-rebase-2.3a09af50.png" alt="通过合并操作来整合分叉了的历史。"></div> <figcaption>Figure 28. 通过合并操作来整合分叉的历史</figcaption></figure> <p>其实，还有一种方法：你可以提取在 <code class="literal">C4</code> 中引入的补丁和修改，然后在 <code class="literal">C3</code> 的基础上应用一次。
在 Git 中，这种操作就叫做 <strong>变基（rebase）</strong>。
你可以使用 <code class="literal">rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p> <p>在这个例子中，你可以检出 <code class="literal">experiment</code> 分支，然后将它变基到 <code class="literal">master</code> 分支上：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout experiment
<span style="font-weight:bold;">$</span> git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command</code></pre> <p>它的原理是首先找到这两个分支（即当前分支 <code class="literal">experiment</code>、变基操作的目标基底分支 <code class="literal">master</code>）
的最近共同祖先 <code class="literal">C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，
然后将当前分支指向目标基底 <code class="literal">C3</code>, 最后以此将之前另存为临时文件的修改依序应用。
（译注：写明了 commit id，以便理解，下同）</p> <figure class="image"><div class="content"><img src="/assets/img/basic-rebase-3.02d28458.png" alt="将 `C4` 中的修改变基到 `C3` 上。"></div> <figcaption>Figure 29. 将 <code class="literal">C4</code> 中的修改变基到 <code class="literal">C3</code> 上</figcaption></figure> <p>现在回到 <code class="literal">master</code> 分支，进行一次快进合并。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout master
<span style="font-weight:bold;">$</span> git merge experiment</code></pre> <figure class="image"><div class="content"><img src="/assets/img/basic-rebase-4.69f3834f.png" alt="`master` 分支的快进合并。"></div> <figcaption>Figure 30. <code class="literal">master</code> 分支的快进合并</figcaption></figure> <p>此时，<code class="literal">C4'</code> 指向的快照就和 <a id="xref-ebasing-merging-example" href="#ebasing-merging-example" class="xref">the merge example</a> 中 <code class="literal">C5</code> 指向的快照一模一样了。
这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。
你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，
但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</p> <p>一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。
在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 <code class="literal">origin/master</code> 上，然后再向主项目提交修改。
这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。</p> <p>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。
变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。</p> <h2 id="更有趣的变基例子"><a href="#更有趣的变基例子" class="header-anchor">#</a> 更有趣的变基例子</h2> <p>在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。
就像 <a id="xref-bdiag_e" href="#bdiag_e" class="xref">从一个主题分支里再分出一个主题分支的提交历史</a> 中的例子那样。
你创建了一个主题分支 <code class="literal">server</code>，为服务端添加了一些功能，提交了 <code class="literal">C3</code> 和 <code class="literal">C4</code>。
然后从 <code class="literal">C3</code> 上创建了主题分支 <code class="literal">client</code>，为客户端添加了一些功能，提交了 <code class="literal">C8</code> 和 <code class="literal">C9</code>。
最后，你回到 <code class="literal">server</code> 分支，又提交了 <code class="literal">C10</code>。</p> <figure id="bdiag_e" class="image"><div class="content"><img src="/assets/img/interesting-rebase-1.c5dd8661.png" alt="从一个主题分支里再分出一个主题分支的提交历史。"></div> <figcaption>Figure 31. 从一个主题分支里再分出一个主题分支的提交历史</figcaption></figure> <p>假设你希望将 <code class="literal">client</code> 中的修改合并到主分支并发布，但暂时并不想合并 <code class="literal">server</code> 中的修改，
因为它们还需要经过更全面的测试。这时，你就可以使用 <code class="literal">git rebase</code> 命令的 <code class="literal">--onto</code> 选项，
选中在 <code class="literal">client</code> 分支里但不在 <code class="literal">server</code> 分支里的修改（即 <code class="literal">C8</code> 和 <code class="literal">C9</code>），将它们在 <code class="literal">master</code> 分支上重放：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git rebase --onto master server client</code></pre> <p>以上命令的意思是：“取出 <code class="literal">client</code> 分支，找出它从 <code class="literal">server</code> 分支分歧之后的补丁，
然后把这些补丁在 <code class="literal">master</code> 分支上重放一遍，让 <code class="literal">client</code> 看起来像直接基于
<code class="literal">master</code> 修改一样”。这理解起来有一点复杂，不过效果非常酷。</p> <figure class="image"><div class="content"><img src="/assets/img/interesting-rebase-2.4b7bc09d.png" alt="截取主题分支上的另一个主题分支，然后变基到其他分支。"></div> <figcaption>Figure 32. 截取主题分支上的另一个主题分支，然后变基到其他分支</figcaption></figure> <p>现在可以快进合并 <code class="literal">master</code> 分支了。（如图 <a id="xref-bdiag_g" href="#bdiag_g" class="xref">快进合并 <code class="literal">master</code> 分支，使之包含来自 <code class="literal">client</code> 分支的修改</a>）：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout master
<span style="font-weight:bold;">$</span> git merge client</code></pre> <figure id="bdiag_g" class="image"><div class="content"><img src="/assets/img/interesting-rebase-3.a7bc56bf.png" alt="快进合并 `master` 分支，使之包含来自 `client` 分支的修改。"></div> <figcaption>Figure 33. 快进合并 <code class="literal">master</code> 分支，使之包含来自 <code class="literal">client</code> 分支的修改</figcaption></figure> <p>接下来你决定将 <code class="literal">server</code> 分支中的修改也整合进来。
使用 <code class="literal">git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 命令可以直接将主题分支
（即本例中的 <code class="literal">server</code>）变基到目标分支（即 <code class="literal">master</code>）上。
这样做能省去你先切换到 <code class="literal">server</code> 分支，再对其执行变基命令的多个步骤。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git rebase master server</code></pre> <p>如图 <a id="xref-bdiag_h" href="#bdiag_h" class="xref">将 <code class="literal">server</code> 中的修改变基到 <code class="literal">master</code> 上</a> 所示，<code class="literal">server</code> 中的代码被“续”到了 <code class="literal">master</code> 后面。</p> <figure id="bdiag_h" class="image"><div class="content"><img src="/assets/img/interesting-rebase-4.52e1b121.png" alt="将 `server` 中的修改变基到 `master` 上。"></div> <figcaption>Figure 34. 将 <code class="literal">server</code> 中的修改变基到 <code class="literal">master</code> 上</figcaption></figure> <p>然后就可以快进合并主分支 <code class="literal">master</code> 了：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git checkout master
<span style="font-weight:bold;">$</span> git merge server</code></pre> <p>至此，<code class="literal">client</code> 和 <code class="literal">server</code> 分支中的修改都已经整合到主分支里了，
你可以删除这两个分支，最终提交历史会变成图 <a id="xref-bdiag_i" href="#bdiag_i" class="xref">最终的提交历史</a> 中的样子：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git branch -d client
<span style="font-weight:bold;">$</span> git branch -d server</code></pre> <figure id="bdiag_i" class="image"><div class="content"><img src="/assets/img/interesting-rebase-5.4c501e59.png" alt="最终的提交历史。"></div> <figcaption>Figure 35. 最终的提交历史</figcaption></figure> <h2 id="变基的风险"><a href="#变基的风险" class="header-anchor">#</a> 变基的风险</h2> <p>
呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p> <p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p> <p>如果你遵循这条金科玉律，就不会出差错。
否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p> <p>变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。
如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code class="literal">git rebase</code> 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。</p> <p>让我们来看一个在公开的仓库上执行变基操作所带来的问题。
假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。
你的提交历史如图所示：</p> <figure class="image"><div class="content"><img src="/assets/img/perils-of-rebasing-1.7acceecd.png" alt="克隆一个仓库，然后在它的基础上进行了一些开发。"></div> <figcaption>Figure 36. 克隆一个仓库，然后在它的基础上进行了一些开发</figcaption></figure> <p>然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。
你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：</p> <figure class="image"><div class="content"><img src="/assets/img/perils-of-rebasing-2.238130b4.png" alt="抓取别人的提交，合并到自己的开发分支。"></div> <figcaption>Figure 37. 抓取别人的提交，合并到自己的开发分支</figcaption></figure> <p>接下来，这个人又决定把合并操作回滚，改用变基；继而又用 <code class="literal">git push --force</code> 命令覆盖了服务器上的提交历史。
之后你从服务器抓取更新，会发现多出来一些新的提交。</p> <figure id="_pre_merge_rebase_work" class="image"><div class="content"><img src="/assets/img/perils-of-rebasing-3.b49bff2d.png" alt="有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。"></div> <figcaption>Figure 38. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</figcaption></figure> <p>结果就是你们两人的处境都十分尴尬。
如果你执行 <code class="literal">git pull</code> 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：</p> <figure id="_merge_rebase_work" class="image"><div class="content"><img src="/assets/img/perils-of-rebasing-4.731519fb.png" alt="你将相同的内容又合并了一次，生成了一个新的提交。"></div> <figcaption>Figure 39. 你将相同的内容又合并了一次，生成了一个新的提交</figcaption></figure> <p>此时如果你执行 <code class="literal">git log</code> 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。
此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。
很明显对方并不想在提交历史中看到 <code class="literal">C4</code> 和 <code class="literal">C6</code>，因为之前就是他把这两个提交通过变基丢弃的。</p> <h2 id="用变基解决变基"><a href="#用变基解决变基" class="header-anchor">#</a> 用变基解决变基</h2> <p>如果你 <strong>真的</strong> 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。
如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。</p> <p>实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。</p> <p>如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。</p> <p>举个例子，如果遇到前面提到的 <a id="xref-_pre_merge_rebase_work" href="#_pre_merge_rebase_work" class="xref">有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交</a> 那种情境，如果我们不是执行合并，而是执行 <code class="literal">git rebase teamone/master</code>, Git 将会：</p> <div class="itemized-list"><ul><li><span class="principal">检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</span></li> <li><span class="principal">检查其中哪些提交不是合并操作的结果（C2，C3，C4）</span></li> <li><span class="principal">检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）</span></li> <li><span class="principal">把查到的这些提交应用在 <code class="literal">teamone/master</code> 上面</span></li></ul></div> <p>从而我们将得到与 <a id="xref-_merge_rebase_work" href="#_merge_rebase_work" class="xref">你将相同的内容又合并了一次，生成了一个新的提交</a> 中不同的结果，如图 <a id="xref-_rebase_rebase_work" href="#_rebase_rebase_work" class="xref">在一个被变基然后强制推送的分支上再次执行变基</a> 所示。</p> <figure id="_rebase_rebase_work" class="image"><div class="content"><img src="/assets/img/perils-of-rebasing-5.d74f4f14.png" alt="在一个被变基然后强制推送的分支上再次执行变基。"></div> <figcaption>Figure 40. 在一个被变基然后强制推送的分支上再次执行变基</figcaption></figure> <p>要想上述方案有效，还需要对方在变基时确保 <code class="literal">C4'</code> 和 <code class="literal">C4</code> 是几乎一样的。
否则变基操作将无法识别，并新建另一个类似 <code class="literal">C4</code> 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。</p> <p>在本例中另一种简单的方法是使用 <code class="literal">git pull --rebase</code> 命令而不是直接 <code class="literal">git pull</code>。
又或者你可以自己手动完成这个过程，先 <code class="literal">git fetch</code>，再 <code class="literal">git rebase teamone/master</code>。
You can also simplify this by running a <code class="literal">git pull --rebase</code> instead of a normal <code class="literal">git pull</code>.
Or you could do it manually with a <code class="literal">git fetch</code> followed by a <code class="literal">git rebase teamone/master</code> in this case.</p> <p>如果你习惯使用 <code class="literal">git pull</code> ，同时又希望默认使用选项 <code class="literal">--rebase</code>，你可以执行这条语句 <code class="literal">git config --global pull.rebase true</code> 来更改 <code class="literal">pull.rebase</code> 的默认配置。</p> <p>如果你只对不会离开你电脑的提交执行变基，那就不会有事。
如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。
如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交，
那你就有大麻烦了，你的同事也会因此鄙视你。</p> <p>如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 <code class="literal">git pull --rebase</code> 命令，这样尽管不能避免伤痛，但能有所缓解。</p> <h2 id="变基-vs-合并"><a href="#变基-vs-合并" class="header-anchor">#</a> 变基 vs. 合并</h2> <p>
至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。
在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。</p> <p>有一种观点认为，仓库的提交历史即是 <strong>记录实际发生过什么</strong>。
它是针对历史的文档，本身就有价值，不能乱改。
从这个角度看来，改变提交历史是一种亵渎，你使用 <em>谎言</em> 掩盖了实际发生过的事情。
如果由合并产生的提交历史是一团糟怎么办？
既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。</p> <p>另一种观点则正好相反，他们认为提交历史是 <strong>项目过程中发生的事</strong>。
没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。
持这一观点的人会使用 <code class="literal">rebase</code> 及 <code class="literal">filter-branch</code> 等工具来编写故事，怎么方便后来的读者就怎么写。</p> <p>现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。
Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。
既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。</p> <p>总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，
从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/chapter-3/5.html" class="prev">
        远程分支
      </a></span> <span class="next"><a href="/chapter-3/7.html">
        总结
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e343c26e.js" defer></script><script src="/assets/js/2.c0327591.js" defer></script><script src="/assets/js/7.225eae41.js" defer></script>
  </body>
</html>
