<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>重置揭密 | Pro Git</title>
    <meta name="description" content="Pro Git 第二版中文版">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/assets/css/0.styles.130772cc.css" as="style"><link rel="preload" href="/assets/js/app.e343c26e.js" as="script"><link rel="preload" href="/assets/js/2.c0327591.js" as="script"><link rel="preload" href="/assets/js/4.e8424aa9.js" as="script"><link rel="prefetch" href="/assets/js/10.0f9cab2e.js"><link rel="prefetch" href="/assets/js/100.83085317.js"><link rel="prefetch" href="/assets/js/101.56c6cce3.js"><link rel="prefetch" href="/assets/js/102.415183d7.js"><link rel="prefetch" href="/assets/js/103.65e1f37c.js"><link rel="prefetch" href="/assets/js/104.4844f2f3.js"><link rel="prefetch" href="/assets/js/105.66c87d19.js"><link rel="prefetch" href="/assets/js/106.05b2e48e.js"><link rel="prefetch" href="/assets/js/107.929c5d0f.js"><link rel="prefetch" href="/assets/js/108.7b376e69.js"><link rel="prefetch" href="/assets/js/109.1a730133.js"><link rel="prefetch" href="/assets/js/11.a6d7b909.js"><link rel="prefetch" href="/assets/js/110.191355ad.js"><link rel="prefetch" href="/assets/js/111.a049971f.js"><link rel="prefetch" href="/assets/js/112.482ffc61.js"><link rel="prefetch" href="/assets/js/113.d94b639c.js"><link rel="prefetch" href="/assets/js/114.8b9356fb.js"><link rel="prefetch" href="/assets/js/115.ebf1e18a.js"><link rel="prefetch" href="/assets/js/116.18b899b1.js"><link rel="prefetch" href="/assets/js/117.42a1b8c4.js"><link rel="prefetch" href="/assets/js/118.3a9d2ee3.js"><link rel="prefetch" href="/assets/js/119.4020833f.js"><link rel="prefetch" href="/assets/js/12.5d2796d3.js"><link rel="prefetch" href="/assets/js/120.9fae7990.js"><link rel="prefetch" href="/assets/js/121.cb3ef973.js"><link rel="prefetch" href="/assets/js/13.f69c9e48.js"><link rel="prefetch" href="/assets/js/14.6debe4be.js"><link rel="prefetch" href="/assets/js/15.a7c94022.js"><link rel="prefetch" href="/assets/js/16.6609021c.js"><link rel="prefetch" href="/assets/js/17.34ba32b5.js"><link rel="prefetch" href="/assets/js/18.4dd74348.js"><link rel="prefetch" href="/assets/js/19.2f410429.js"><link rel="prefetch" href="/assets/js/20.16ec0bd3.js"><link rel="prefetch" href="/assets/js/21.ad1ca29b.js"><link rel="prefetch" href="/assets/js/22.293aa5c6.js"><link rel="prefetch" href="/assets/js/23.025d3c7a.js"><link rel="prefetch" href="/assets/js/24.770fb3e1.js"><link rel="prefetch" href="/assets/js/25.6ce5a0ac.js"><link rel="prefetch" href="/assets/js/26.6404265b.js"><link rel="prefetch" href="/assets/js/27.62decef4.js"><link rel="prefetch" href="/assets/js/28.d1136794.js"><link rel="prefetch" href="/assets/js/29.95a71153.js"><link rel="prefetch" href="/assets/js/3.c6496835.js"><link rel="prefetch" href="/assets/js/30.eae133de.js"><link rel="prefetch" href="/assets/js/31.a6e572c3.js"><link rel="prefetch" href="/assets/js/32.4fc54ce1.js"><link rel="prefetch" href="/assets/js/33.d1c0ecba.js"><link rel="prefetch" href="/assets/js/34.29586ee8.js"><link rel="prefetch" href="/assets/js/35.8e480916.js"><link rel="prefetch" href="/assets/js/36.5b537183.js"><link rel="prefetch" href="/assets/js/37.40c06fd9.js"><link rel="prefetch" href="/assets/js/38.555815d4.js"><link rel="prefetch" href="/assets/js/39.6d5293e5.js"><link rel="prefetch" href="/assets/js/40.78797741.js"><link rel="prefetch" href="/assets/js/41.ac76af08.js"><link rel="prefetch" href="/assets/js/42.e7d51b5d.js"><link rel="prefetch" href="/assets/js/43.b20d0fd6.js"><link rel="prefetch" href="/assets/js/44.e29a7c46.js"><link rel="prefetch" href="/assets/js/45.cdea70ee.js"><link rel="prefetch" href="/assets/js/46.9c95c270.js"><link rel="prefetch" href="/assets/js/47.ba588e60.js"><link rel="prefetch" href="/assets/js/48.a8b188ed.js"><link rel="prefetch" href="/assets/js/49.5c609647.js"><link rel="prefetch" href="/assets/js/5.b1d6f09c.js"><link rel="prefetch" href="/assets/js/50.662cc18e.js"><link rel="prefetch" href="/assets/js/51.5ff994dd.js"><link rel="prefetch" href="/assets/js/52.b1b6dd6c.js"><link rel="prefetch" href="/assets/js/53.bd783506.js"><link rel="prefetch" href="/assets/js/54.a05ff5b6.js"><link rel="prefetch" href="/assets/js/55.c30a6cad.js"><link rel="prefetch" href="/assets/js/56.44021f37.js"><link rel="prefetch" href="/assets/js/57.90e56f36.js"><link rel="prefetch" href="/assets/js/58.9ec15505.js"><link rel="prefetch" href="/assets/js/59.8f4ffc72.js"><link rel="prefetch" href="/assets/js/6.49fca771.js"><link rel="prefetch" href="/assets/js/60.8064b38b.js"><link rel="prefetch" href="/assets/js/61.d570ac20.js"><link rel="prefetch" href="/assets/js/62.c66ac933.js"><link rel="prefetch" href="/assets/js/63.d01f285e.js"><link rel="prefetch" href="/assets/js/64.a04e3c07.js"><link rel="prefetch" href="/assets/js/65.af0f13b3.js"><link rel="prefetch" href="/assets/js/66.f81074cc.js"><link rel="prefetch" href="/assets/js/67.47db8798.js"><link rel="prefetch" href="/assets/js/68.50332586.js"><link rel="prefetch" href="/assets/js/69.059056ac.js"><link rel="prefetch" href="/assets/js/7.225eae41.js"><link rel="prefetch" href="/assets/js/70.c46fd0e9.js"><link rel="prefetch" href="/assets/js/71.d45f53f9.js"><link rel="prefetch" href="/assets/js/72.eef7975a.js"><link rel="prefetch" href="/assets/js/73.d947c914.js"><link rel="prefetch" href="/assets/js/74.cc528edb.js"><link rel="prefetch" href="/assets/js/75.7e89a25f.js"><link rel="prefetch" href="/assets/js/76.68b7cb39.js"><link rel="prefetch" href="/assets/js/77.f51671b0.js"><link rel="prefetch" href="/assets/js/78.d940a766.js"><link rel="prefetch" href="/assets/js/79.657d22ce.js"><link rel="prefetch" href="/assets/js/8.1c488769.js"><link rel="prefetch" href="/assets/js/80.b7eef56c.js"><link rel="prefetch" href="/assets/js/81.5a9ab73c.js"><link rel="prefetch" href="/assets/js/82.82f8101f.js"><link rel="prefetch" href="/assets/js/83.16c731ea.js"><link rel="prefetch" href="/assets/js/84.ebb4499e.js"><link rel="prefetch" href="/assets/js/85.323932c6.js"><link rel="prefetch" href="/assets/js/86.5fe42af0.js"><link rel="prefetch" href="/assets/js/87.1e607b95.js"><link rel="prefetch" href="/assets/js/88.1cb1bb53.js"><link rel="prefetch" href="/assets/js/89.30b0fda7.js"><link rel="prefetch" href="/assets/js/9.c748d72e.js"><link rel="prefetch" href="/assets/js/90.050be28f.js"><link rel="prefetch" href="/assets/js/91.57dee3b4.js"><link rel="prefetch" href="/assets/js/92.5ec93ebb.js"><link rel="prefetch" href="/assets/js/93.5a3e28cc.js"><link rel="prefetch" href="/assets/js/94.ab209645.js"><link rel="prefetch" href="/assets/js/95.2a4ea0e2.js"><link rel="prefetch" href="/assets/js/96.41db9364.js"><link rel="prefetch" href="/assets/js/97.b936622c.js"><link rel="prefetch" href="/assets/js/98.32537222.js"><link rel="prefetch" href="/assets/js/99.64a3e64d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.130772cc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Pro Git</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">引言</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-1/" class="sidebar-heading clickable"><span>1. 起步</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-2/" class="sidebar-heading clickable"><span>2. Git 基础</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-3/" class="sidebar-heading clickable"><span>3. Git 分支</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-4/" class="sidebar-heading clickable"><span>4. 服务器上的 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-5/" class="sidebar-heading clickable"><span>5. 分布式 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-6/" class="sidebar-heading clickable"><span>6. GitHub</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-7/" class="sidebar-heading clickable router-link-active open"><span>7. Git 工具</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/chapter-7/1.html" class="sidebar-link">选择修订版本</a></li><li><a href="/chapter-7/2.html" class="sidebar-link">交互式暂存</a></li><li><a href="/chapter-7/3.html" class="sidebar-link">贮藏与清理</a></li><li><a href="/chapter-7/4.html" class="sidebar-link">签署工作</a></li><li><a href="/chapter-7/5.html" class="sidebar-link">搜索</a></li><li><a href="/chapter-7/6.html" class="sidebar-link">重写历史</a></li><li><a href="/chapter-7/7.html" class="active sidebar-link">重置揭密</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/chapter-7/7.html#三棵树" class="sidebar-link">三棵树</a></li><li class="sidebar-sub-header"><a href="/chapter-7/7.html#工作流程" class="sidebar-link">工作流程</a></li><li class="sidebar-sub-header"><a href="/chapter-7/7.html#重置的作用" class="sidebar-link">重置的作用</a></li><li class="sidebar-sub-header"><a href="/chapter-7/7.html#通过路径来重置" class="sidebar-link">通过路径来重置</a></li><li class="sidebar-sub-header"><a href="/chapter-7/7.html#压缩" class="sidebar-link">压缩</a></li><li class="sidebar-sub-header"><a href="/chapter-7/7.html#检出" class="sidebar-link">检出</a></li><li class="sidebar-sub-header"><a href="/chapter-7/7.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/chapter-7/8.html" class="sidebar-link">高级合并</a></li><li><a href="/chapter-7/9.html" class="sidebar-link">Rerere</a></li><li><a href="/chapter-7/10.html" class="sidebar-link">使用 Git 调试</a></li><li><a href="/chapter-7/11.html" class="sidebar-link">子模块</a></li><li><a href="/chapter-7/12.html" class="sidebar-link">打包</a></li><li><a href="/chapter-7/13.html" class="sidebar-link">替换</a></li><li><a href="/chapter-7/14.html" class="sidebar-link">凭证存储</a></li><li><a href="/chapter-7/15.html" class="sidebar-link">总结</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-8/" class="sidebar-heading clickable"><span>8. 自定义 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-9/" class="sidebar-heading clickable"><span>9. Git 与其他系统</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/chapter-10/" class="sidebar-heading clickable"><span>10. Git 内部原理</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/appendix-A/" class="sidebar-heading clickable"><span>附录 A. 在其它环境中使用 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/appendix-B/" class="sidebar-heading clickable"><span>附录 B. 在你的应用中嵌入 Git</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/appendix-C/" class="sidebar-heading clickable"><span>附录 C. Git 命令</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="重置揭密"><a href="#重置揭密" class="header-anchor">#</a> 重置揭密</h1> <p>在继续了解更专业的工具前，我们先探讨一下 Git 的 <code class="literal">reset</code> 和 <code class="literal">checkout</code> 命令。
在初遇的 Git 命令中，这两个是最让人困惑的。
它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。
针对这一点，我们先来做一个简单的比喻。</p> <h2 id="三棵树"><a href="#三棵树" class="header-anchor">#</a> 三棵树</h2> <p>理解 <code class="literal">reset</code> 和 <code class="literal">checkout</code> 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。
“树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。
（在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）</p> <p>Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：</p> <div class="table"><div class="content"><table class="table table-framed-topbot table-grid-rows" style="width:100%;"><colgroup><col> <col></colgroup> <thead><tr><th>树</th> <th>用途</th></tr></thead> <tbody><tr><td><p>HEAD</p></td> <td><p>上一次提交的快照，下一次提交的父结点</p></td></tr> <tr><td><p>Index</p></td> <td><p>预期的下一次提交的快照</p></td></tr> <tr><td><p>Working Directory</p></td> <td><p>沙盒</p></td></tr></tbody></table></div></div> <h3 id="head"><a href="#head" class="header-anchor">#</a> HEAD</h3> <p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。
这表示 HEAD 将是下一次提交的父结点。
通常，理解 HEAD 的最简方式，就是将它看做 <strong>该分支上的最后一次提交</strong> 的快照。</p> <p>其实，查看快照的样子很容易。
下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

<span style="font-weight:bold;">$</span> git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib</code></pre> <p>Git 的 <code class="literal">cat-file</code> 和 <code class="literal">ls-tree</code> 是底层命令，它们一般用于底层工作，在日常工作中并不使用。
不过它们能帮助我们了解到底发生了什么。</p> <h3 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h3> <p>索引是你的 <strong>预期的下一次提交</strong>。
我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 <code class="literal">git commit</code> 时 Git 看起来的样子。</p> <p>Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。
之后你会将其中一些文件替换为新版本，接着通过 <code class="literal">git commit</code> 将它们转换为树来用作新的提交。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb</code></pre> <p>再说一次，我们在这里又用到了 <code class="literal">git ls-files</code> 这个幕后的命令，它会显示出索引当前的样子。</p> <p>确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。</p> <h3 id="工作目录"><a href="#工作目录" class="header-anchor">#</a> 工作目录</h3> <p>最后，你就有了自己的 <strong>工作目录</strong>（通常也叫 <strong>工作区</strong>）。
另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 <code class="literal">.git</code> 文件夹中。
工作目录会将它们解包为实际的文件以便编辑。
你可以把工作目录当做 <strong>沙盒</strong>。在你将修改提交到暂存区并记录到历史之前，可以随意更改。</p> <pre class="language-bash"><code><span style="font-weight:bold;">$</span> tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files</code></pre> <h2 id="工作流程"><a href="#工作流程" class="header-anchor">#</a> 工作流程</h2> <p>经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-workflow.7d8a0685.png" alt="reset workflow"></div></figure> <p>让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。
我们称其为该文件的 <strong>v1</strong> 版本，将它标记为蓝色。
现在运行 <code class="literal">git init</code>，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的 <code class="literal">master</code> 分支。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-ex1.2af73d25.png" alt="reset ex1"></div></figure> <p>此时，只有工作目录有内容。</p> <p>现在我们想要提交这个文件，所以用 <code class="literal">git add</code> 来获取工作目录中的内容，并将其复制到索引中。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-ex2.4c5377d9.png" alt="reset ex2"></div></figure> <p>接着运行 <code class="literal">git commit</code>，它会取得索引中的内容并将它保存为一个永久的快照，
然后创建一个指向该快照的提交对象，最后更新 <code class="literal">master</code> 来指向本次提交。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-ex3.e7356b44.png" alt="reset ex3"></div></figure> <p>此时如果我们运行 <code class="literal">git status</code>，会发现没有任何改动，因为现在三棵树完全相同。</p> <p>现在我们想要对文件进行修改然后提交它。
我们将会经历同样的过程；首先在工作目录中修改文件。
我们称其为该文件的 <strong>v2</strong> 版本，并将它标记为红色。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-ex4.e961ab64.png" alt="reset ex4"></div></figure> <p>如果现在运行 <code class="literal">git status</code>，我们会看到文件显示在 “Changes not staged for commit”
下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。
接着我们运行 <code class="literal">git add</code> 来将它暂存到索引中。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-ex5.403abc40.png" alt="reset ex5"></div></figure> <p>此时，由于索引和 HEAD 不同，若运行 <code class="literal">git status</code> 的话就会看到 “Changes to be committed” 下的该文件变为绿色
——也就是说，现在预期的下一次提交与上一次提交不同。
最后，我们运行 <code class="literal">git commit</code> 来完成提交。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-ex6.19922894.png" alt="reset ex6"></div></figure> <p>现在运行 <code class="literal">git status</code> 会没有输出，因为三棵树又变得相同了。</p> <p>切换分支或克隆的过程也类似。
当检出一个分支时，它会修改 <strong>HEAD</strong> 指向新的分支引用，将 <strong>索引</strong> 填充为该次提交的快照，
然后将 <strong>索引</strong> 的内容复制到 <strong>工作目录</strong> 中。</p> <h2 id="重置的作用"><a href="#重置的作用" class="header-anchor">#</a> 重置的作用</h2> <p>在以下情景中观察 <code class="literal">reset</code> 命令会更有意义。</p> <p>为了演示这些例子，假设我们再次修改了 <code class="literal">file.txt</code> 文件并第三次提交它。
现在的历史看起来是这样的：</p> <figure class="image"><div class="content"><img src="/assets/img/reset-start.9f172c68.png" alt="reset start"></div></figure> <p>让我们跟着 <code class="literal">reset</code> 看看它都做了什么。
它以一种简单可预见的方式直接操纵这三棵树。
它做了三个基本操作。</p> <h3 id="第-1-步：移动-head"><a href="#第-1-步：移动-head" class="header-anchor">#</a> 第 1 步：移动 HEAD</h3> <p><code class="literal">reset</code> 做的第一件事是移动 HEAD 的指向。
这与改变 HEAD 自身不同（<code class="literal">checkout</code> 所做的）；<code class="literal">reset</code> 移动 HEAD 指向的分支。
这意味着如果 HEAD 设置为 <code class="literal">master</code> 分支（例如，你正在 <code class="literal">master</code> 分支上），
运行 <code class="literal">git reset 9e5e6a4</code> 将会使 <code class="literal">master</code> 指向 <code class="literal">9e5e6a4</code>。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-soft.f7eaaba7.png" alt="reset soft"></div></figure> <p>无论你调用了何种形式的带有一个提交的 <code class="literal">reset</code>，它首先都会尝试这样做。
使用 <code class="literal">reset --soft</code>，它将仅仅停在那儿。</p> <p>现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 <code class="literal">git commit</code> 命令。
当你在运行 <code class="literal">git commit</code> 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。
当你将它 <code class="literal">reset</code> 回 <code class="literal">HEAD~</code>（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。
现在你可以更新索引并再次运行 <code class="literal">git commit</code> 来完成 <code class="literal">git commit --amend</code> 所要做的事情了（见 <a id="xref-_git_amend" href="#_git_amend" class="xref">修改最后一次提交</a>）。</p> <h3 id="第-2-步：更新索引（-mixed）"><a href="#第-2-步：更新索引（-mixed）" class="header-anchor">#</a> 第 2 步：更新索引（--mixed）</h3> <p>注意，如果你现在运行 <code class="literal">git status</code> 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。</p> <p>接下来，<code class="literal">reset</code> 会用 HEAD 指向的当前快照的内容来更新索引。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-mixed.db24d5d6.png" alt="reset mixed"></div></figure> <p>如果指定 <code class="literal">--mixed</code> 选项，<code class="literal">reset</code> 将会在这时停止。
这也是默认行为，所以如果没有指定任何选项（在本例中只是 <code class="literal">git reset HEAD~</code>），这就是命令将会停止的地方。</p> <p>现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 <code class="literal">提交</code>，但还会 <em>取消暂存</em> 所有的东西。
于是，我们回滚到了所有 <code class="literal">git add</code> 和 <code class="literal">git commit</code> 的命令执行之前。</p> <h3 id="第-3-步：更新工作目录（-hard）"><a href="#第-3-步：更新工作目录（-hard）" class="header-anchor">#</a> 第 3 步：更新工作目录（--hard）</h3> <p><code class="literal">reset</code> 要做的的第三件事情就是让工作目录看起来像索引。
如果使用 <code class="literal">--hard</code> 选项，它将会继续这一步。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-hard.9a4df6ec.png" alt="reset hard"></div></figure> <p>现在让我们回想一下刚才发生的事情。
你撤销了最后的提交、<code class="literal">git add</code> 和 <code class="literal">git commit</code> 命令 <strong>以及</strong> 工作目录中的所有工作。</p> <p>必须注意，<code class="literal">--hard</code> 标记是 <code class="literal">reset</code> 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。
其他任何形式的 <code class="literal">reset</code> 调用都可以轻松撤消，但是 <code class="literal">--hard</code> 选项不能，因为它强制覆盖了工作目录中的文件。
在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 <strong>v3</strong> 版本，
我们可以通过 <code class="literal">reflog</code> 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。</p> <h3 id="回顾"><a href="#回顾" class="header-anchor">#</a> 回顾</h3> <p><code class="literal">reset</code> 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：</p> <div class="ordered-list arabic"><ol class="arabic"><li><span class="principal">移动 HEAD 分支的指向 <em>（若指定了 <code class="literal">--soft</code>，则到此停止）</em></span></li> <li><span class="principal">使索引看起来像 HEAD <em>（若未指定 <code class="literal">--hard</code>，则到此停止）</em></span></li> <li><span class="principal">使工作目录看起来像索引</span></li></ol></div> <h2 id="通过路径来重置"><a href="#通过路径来重置" class="header-anchor">#</a> 通过路径来重置</h2> <p>前面讲述了 <code class="literal">reset</code> 基本形式的行为，不过你还可以给它提供一个作用路径。
若指定了一个路径，<code class="literal">reset</code> 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。
这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。
不过索引和工作目录 <em>可以部分更新</em>，所以重置会继续进行第 2、3 步。</p> <p>现在，假如我们运行 <code class="literal">git reset file.txt</code>
（这其实是 <code class="literal">git reset --mixed HEAD file.txt</code> 的简写形式，因为你既没有指定一个提交的
SHA-1 或分支，也没有指定 <code class="literal">--soft</code> 或 <code class="literal">--hard</code>），它会：</p> <div class="ordered-list arabic"><ol class="arabic"><li><span class="principal">移动 HEAD 分支的指向 <em>（已跳过）</em></span></li> <li><span class="principal">让索引看起来像 HEAD <em>（到此处停止）</em></span></li></ol></div> <p>所以它本质上只是将 <code class="literal">file.txt</code> 从 HEAD 复制到索引中。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-path1.41e7c15f.png" alt="reset path1"></div></figure> <p>它还有 <em>取消暂存文件</em> 的实际效果。
如果我们查看该命令的示意图，然后再想想 <code class="literal">git add</code> 所做的事，就会发现它们正好相反。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-path2.6dfef937.png" alt="reset path2"></div></figure> <p>这就是为什么 <code class="literal">git status</code> 命令的输出会建议运行此命令来取消暂存一个文件。
（查看 <a id="xref--ch02-git-basics-chapter--_unstaging" href="/chapter-2/4.html#取消暂存的文件" class="xref">取消暂存的文件</a> 来了解更多。）</p> <p>我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。
我们只需运行类似于 <code class="literal">git reset eb43bf file.txt</code> 的命令即可。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-path3.5d460d4a.png" alt="reset path3"></div></figure> <p>它其实做了同样的事情，也就是把工作目录中的文件恢复到 <strong>v1</strong> 版本，运行 <code class="literal">git add</code> 添加它，
然后再将它恢复到 <strong>v3</strong> 版本（只是不用真的过一遍这些步骤）。
如果我们现在运行 <code class="literal">git commit</code>，它就会记录一条“将该文件恢复到 <strong>v1</strong> 版本”的更改，
尽管我们并未在工作目录中真正地再次拥有它。</p> <p>还有一点同 <code class="literal">git add</code> 一样，就是 <code class="literal">reset</code> 命令也可以接受一个 <code class="literal">--patch</code> 选项来一块一块地取消暂存的内容。
这样你就可以根据选择来取消暂存或恢复内容了。</p> <h2 id="压缩"><a href="#压缩" class="header-anchor">#</a> 压缩</h2> <p>我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。</p> <p>假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”，
聪明的你就能使用 <code class="literal">reset</code> 来轻松快速地将它们压缩成单个提交，也显出你的聪明。
（<a id="xref-_squashing" href="#_squashing" class="xref">压缩提交</a> 展示了另一种方式，不过在本例中用 <code class="literal">reset</code> 更简单。）</p> <p>假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。
由于第二次提交是一个未完成的工作，因此你想要压缩它。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-squash-r1.51adb0c5.png" alt="reset squash r1"></div></figure> <p>那么可以运行 <code class="literal">git reset --soft HEAD~2</code> 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：</p> <figure class="image"><div class="content"><img src="/assets/img/reset-squash-r2.2da8d827.png" alt="reset squash r2"></div></figure> <p>然后只需再次运行 <code class="literal">git commit</code>：</p> <figure class="image"><div class="content"><img src="/assets/img/reset-squash-r3.2a3ce36e.png" alt="reset squash r3"></div></figure> <p>现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 <code class="literal">file-a.txt</code> 的提交，
接着第二个提交将 <code class="literal">file-a.txt</code> 修改成了 v3 版并增加了 <code class="literal">file-b.txt</code>。
包含 v2 版本的文件已经不在历史中了。</p> <h2 id="检出"><a href="#检出" class="header-anchor">#</a> 检出</h2> <p>最后，你大概还想知道 <code class="literal">checkout</code> 和 <code class="literal">reset</code> 之间的区别。
和 <code class="literal">reset</code> 一样，<code class="literal">checkout</code> 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。</p> <h3 id="不带路径"><a href="#不带路径" class="header-anchor">#</a> 不带路径</h3> <p>运行 <code class="literal">git checkout [branch]</code> 与运行 <code class="literal">git reset --hard [branch]</code> 非常相似，它会更新所有三棵树使其看起来像 <code class="literal">[branch]</code>，不过有两点重要的区别。</p> <p>首先不同于 <code class="literal">reset --hard</code>，<code class="literal">checkout</code> 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。
其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。
而 <code class="literal">reset --hard</code> 则会不做检查就全面地替换所有东西。</p> <p>第二个重要的区别是 <code class="literal">checkout</code> 如何更新 HEAD。
<code class="literal">reset</code> 会移动 HEAD 分支的指向，而 <code class="literal">checkout</code> 只会移动 HEAD 自身来指向另一个分支。</p> <p>例如，假设我们有 <code class="literal">master</code> 和 <code class="literal">develop</code> 分支，它们分别指向不同的提交；我们现在在 <code class="literal">develop</code> 上（所以 HEAD 指向它）。
如果我们运行 <code class="literal">git reset master</code>，那么 <code class="literal">develop</code> 自身现在会和 <code class="literal">master</code> 指向同一个提交。
而如果我们运行 <code class="literal">git checkout master</code> 的话，<code class="literal">develop</code> 不会移动，HEAD 自身会移动。
现在 HEAD 将会指向 <code class="literal">master</code>。</p> <p>所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。
<code class="literal">reset</code> 会移动 HEAD 分支的指向，而 <code class="literal">checkout</code> 则移动 HEAD 自身。</p> <figure class="image"><div class="content"><img src="/assets/img/reset-checkout.0c12d0a8.png" alt="reset checkout"></div></figure> <h3 id="带路径"><a href="#带路径" class="header-anchor">#</a> 带路径</h3> <p>运行 <code class="literal">checkout</code> 的另一种方式就是指定一个文件路径，这会像 <code class="literal">reset</code> 一样不会移动 HEAD。
它就像 <code class="literal">git reset [branch] file</code> 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。
它就像是 <code class="literal">git reset --hard [branch] file</code>（如果 <code class="literal">reset</code> 允许你这样运行的话），
这样对工作目录并不安全，它也不会移动 HEAD。</p> <p>此外，同 <code class="literal">git reset</code> 和 <code class="literal">git add</code> 一样，<code class="literal">checkout</code> 也接受一个 <code class="literal">--patch</code> 选项，允许你根据选择一块一块地恢复文件内容。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>希望你现在熟悉并理解了 <code class="literal">reset</code> 命令，不过关于它和 <code class="literal">checkout</code> 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。</p> <p>下面的速查表列出了命令对树的影响。
“HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。
特别注意 <em>WD Safe?</em> 一列——如果它标记为 <strong>NO</strong>，那么运行该命令之前请考虑一下。</p> <div class="table"><div class="content"><table class="table table-framed-topbot table-grid-rows" style="width:100%;"><colgroup><col> <col> <col> <col> <col></colgroup> <thead><tr><th></th> <th>HEAD</th> <th>Index</th> <th>Workdir</th> <th>WD Safe?</th></tr></thead> <tbody><tr><td><p><strong>Commit Level</strong></p></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td><p><code class="literal">reset --soft [commit]</code></p></td> <td><p>REF</p></td> <td><p>NO</p></td> <td><p>NO</p></td> <td><p>YES</p></td></tr> <tr><td><p><code class="literal">reset [commit]</code></p></td> <td><p>REF</p></td> <td><p>YES</p></td> <td><p>NO</p></td> <td><p>YES</p></td></tr> <tr><td><p><code class="literal">reset --hard [commit]</code></p></td> <td><p>REF</p></td> <td><p>YES</p></td> <td><p>YES</p></td> <td><p><strong>NO</strong></p></td></tr> <tr><td><p><code class="literal">checkout &lt;commit&gt;</code></p></td> <td><p>HEAD</p></td> <td><p>YES</p></td> <td><p>YES</p></td> <td><p>YES</p></td></tr> <tr><td><p><strong>File Level</strong></p></td> <td></td> <td></td> <td></td> <td></td></tr> <tr><td><p><code class="literal">reset [commit] &lt;paths&gt;</code></p></td> <td><p>NO</p></td> <td><p>YES</p></td> <td><p>NO</p></td> <td><p>YES</p></td></tr> <tr><td><p><code class="literal">checkout [commit] &lt;paths&gt;</code></p></td> <td><p>NO</p></td> <td><p>YES</p></td> <td><p>YES</p></td> <td><p><strong>NO</strong></p></td></tr></tbody></table></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/chapter-7/6.html" class="prev">
        重写历史
      </a></span> <span class="next"><a href="/chapter-7/8.html">
        高级合并
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e343c26e.js" defer></script><script src="/assets/js/2.c0327591.js" defer></script><script src="/assets/js/4.e8424aa9.js" defer></script>
  </body>
</html>
